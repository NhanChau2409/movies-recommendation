# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateGenres {
  _avg: GenresAvgAggregate
  _count: GenresCountAggregate
  _max: GenresMaxAggregate
  _min: GenresMinAggregate
  _sum: GenresSumAggregate
}

type AggregateMovieGenres {
  _avg: MovieGenresAvgAggregate
  _count: MovieGenresCountAggregate
  _max: MovieGenresMaxAggregate
  _min: MovieGenresMinAggregate
  _sum: MovieGenresSumAggregate
}

type AggregateMovies {
  _avg: MoviesAvgAggregate
  _count: MoviesCountAggregate
  _max: MoviesMaxAggregate
  _min: MoviesMinAggregate
  _sum: MoviesSumAggregate
}

type AggregateRatings {
  _avg: RatingsAvgAggregate
  _count: RatingsCountAggregate
  _max: RatingsMaxAggregate
  _min: RatingsMinAggregate
  _sum: RatingsSumAggregate
}

type AggregateUsers {
  _avg: UsersAvgAggregate
  _count: UsersCountAggregate
  _max: UsersMaxAggregate
  _min: UsersMinAggregate
  _sum: UsersSumAggregate
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input DateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime!]
}

"""
GraphQL Scalar representing the Prisma.Decimal type, based on Decimal.js library.
"""
scalar Decimal

input DecimalNullableFilter {
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalNullableFilter
  notIn: [Decimal!]
}

input DecimalNullableWithAggregatesFilter {
  _avg: NestedDecimalNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedDecimalNullableFilter
  _min: NestedDecimalNullableFilter
  _sum: NestedDecimalNullableFilter
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalNullableWithAggregatesFilter
  notIn: [Decimal!]
}

input FloatFieldUpdateOperationsInput {
  decrement: Float
  divide: Float
  increment: Float
  multiply: Float
  set: Float
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input FloatWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedFloatFilter
  _min: NestedFloatFilter
  _sum: NestedFloatFilter
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatWithAggregatesFilter
  notIn: [Float!]
}

type Genres {
  MovieGenres(cursor: MovieGenresWhereUniqueInput, distinct: [MovieGenresScalarFieldEnum!], orderBy: [MovieGenresOrderByWithRelationInput!], skip: Int, take: Int, where: MovieGenresWhereInput): [MovieGenres!]!
  _count: GenresCount
  id: Int!
  name: String!
}

type GenresAvgAggregate {
  id: Float
}

input GenresAvgOrderByAggregateInput {
  id: SortOrder
}

type GenresCount {
  MovieGenres(where: MovieGenresWhereInput): Int!
}

type GenresCountAggregate {
  _all: Int!
  id: Int!
  name: Int!
}

input GenresCountOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

input GenresCreateInput {
  MovieGenres: MovieGenresCreateNestedManyWithoutGenresInput
  id: Int!
  name: String!
}

input GenresCreateManyInput {
  id: Int!
  name: String!
}

input GenresCreateNestedOneWithoutMovieGenresInput {
  connect: GenresWhereUniqueInput
  connectOrCreate: GenresCreateOrConnectWithoutMovieGenresInput
  create: GenresCreateWithoutMovieGenresInput
}

input GenresCreateOrConnectWithoutMovieGenresInput {
  create: GenresCreateWithoutMovieGenresInput!
  where: GenresWhereUniqueInput!
}

input GenresCreateWithoutMovieGenresInput {
  id: Int!
  name: String!
}

type GenresGroupBy {
  _avg: GenresAvgAggregate
  _count: GenresCountAggregate
  _max: GenresMaxAggregate
  _min: GenresMinAggregate
  _sum: GenresSumAggregate
  id: Int!
  name: String!
}

type GenresMaxAggregate {
  id: Int
  name: String
}

input GenresMaxOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

type GenresMinAggregate {
  id: Int
  name: String
}

input GenresMinOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

input GenresOrderByWithAggregationInput {
  _avg: GenresAvgOrderByAggregateInput
  _count: GenresCountOrderByAggregateInput
  _max: GenresMaxOrderByAggregateInput
  _min: GenresMinOrderByAggregateInput
  _sum: GenresSumOrderByAggregateInput
  id: SortOrder
  name: SortOrder
}

input GenresOrderByWithRelationInput {
  MovieGenres: MovieGenresOrderByRelationAggregateInput
  id: SortOrder
  name: SortOrder
}

input GenresRelationFilter {
  is: GenresWhereInput
  isNot: GenresWhereInput
}

enum GenresScalarFieldEnum {
  id
  name
}

input GenresScalarWhereWithAggregatesInput {
  AND: [GenresScalarWhereWithAggregatesInput!]
  NOT: [GenresScalarWhereWithAggregatesInput!]
  OR: [GenresScalarWhereWithAggregatesInput!]
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
}

type GenresSumAggregate {
  id: Int
}

input GenresSumOrderByAggregateInput {
  id: SortOrder
}

input GenresUpdateInput {
  MovieGenres: MovieGenresUpdateManyWithoutGenresNestedInput
  id: IntFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input GenresUpdateManyMutationInput {
  id: IntFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input GenresUpdateOneRequiredWithoutMovieGenresNestedInput {
  connect: GenresWhereUniqueInput
  connectOrCreate: GenresCreateOrConnectWithoutMovieGenresInput
  create: GenresCreateWithoutMovieGenresInput
  update: GenresUpdateWithoutMovieGenresInput
  upsert: GenresUpsertWithoutMovieGenresInput
}

input GenresUpdateWithoutMovieGenresInput {
  id: IntFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input GenresUpsertWithoutMovieGenresInput {
  create: GenresCreateWithoutMovieGenresInput!
  update: GenresUpdateWithoutMovieGenresInput!
}

input GenresWhereInput {
  AND: [GenresWhereInput!]
  MovieGenres: MovieGenresListRelationFilter
  NOT: [GenresWhereInput!]
  OR: [GenresWhereInput!]
  id: IntFilter
  name: StringFilter
}

input GenresWhereUniqueInput {
  id: Int
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input IntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

type MovieGenres {
  Genres: Genres!
  Movies: Movies!
  genre_id: Int!
  movie_id: Int!
}

type MovieGenresAvgAggregate {
  genre_id: Float
  movie_id: Float
}

input MovieGenresAvgOrderByAggregateInput {
  genre_id: SortOrder
  movie_id: SortOrder
}

type MovieGenresCountAggregate {
  _all: Int!
  genre_id: Int!
  movie_id: Int!
}

input MovieGenresCountOrderByAggregateInput {
  genre_id: SortOrder
  movie_id: SortOrder
}

input MovieGenresCreateInput {
  Genres: GenresCreateNestedOneWithoutMovieGenresInput!
  Movies: MoviesCreateNestedOneWithoutMovieGenresInput!
}

input MovieGenresCreateManyGenresInput {
  movie_id: Int!
}

input MovieGenresCreateManyGenresInputEnvelope {
  data: [MovieGenresCreateManyGenresInput!]!
}

input MovieGenresCreateManyInput {
  genre_id: Int!
  movie_id: Int!
}

input MovieGenresCreateManyMoviesInput {
  genre_id: Int!
}

input MovieGenresCreateManyMoviesInputEnvelope {
  data: [MovieGenresCreateManyMoviesInput!]!
}

input MovieGenresCreateNestedManyWithoutGenresInput {
  connect: [MovieGenresWhereUniqueInput!]
  connectOrCreate: [MovieGenresCreateOrConnectWithoutGenresInput!]
  create: [MovieGenresCreateWithoutGenresInput!]
  createMany: MovieGenresCreateManyGenresInputEnvelope
}

input MovieGenresCreateNestedManyWithoutMoviesInput {
  connect: [MovieGenresWhereUniqueInput!]
  connectOrCreate: [MovieGenresCreateOrConnectWithoutMoviesInput!]
  create: [MovieGenresCreateWithoutMoviesInput!]
  createMany: MovieGenresCreateManyMoviesInputEnvelope
}

input MovieGenresCreateOrConnectWithoutGenresInput {
  create: MovieGenresCreateWithoutGenresInput!
  where: MovieGenresWhereUniqueInput!
}

input MovieGenresCreateOrConnectWithoutMoviesInput {
  create: MovieGenresCreateWithoutMoviesInput!
  where: MovieGenresWhereUniqueInput!
}

input MovieGenresCreateWithoutGenresInput {
  Movies: MoviesCreateNestedOneWithoutMovieGenresInput!
}

input MovieGenresCreateWithoutMoviesInput {
  Genres: GenresCreateNestedOneWithoutMovieGenresInput!
}

type MovieGenresGroupBy {
  _avg: MovieGenresAvgAggregate
  _count: MovieGenresCountAggregate
  _max: MovieGenresMaxAggregate
  _min: MovieGenresMinAggregate
  _sum: MovieGenresSumAggregate
  genre_id: Int!
  movie_id: Int!
}

input MovieGenresListRelationFilter {
  every: MovieGenresWhereInput
  none: MovieGenresWhereInput
  some: MovieGenresWhereInput
}

type MovieGenresMaxAggregate {
  genre_id: Int
  movie_id: Int
}

input MovieGenresMaxOrderByAggregateInput {
  genre_id: SortOrder
  movie_id: SortOrder
}

type MovieGenresMinAggregate {
  genre_id: Int
  movie_id: Int
}

input MovieGenresMinOrderByAggregateInput {
  genre_id: SortOrder
  movie_id: SortOrder
}

input MovieGenresMovie_idGenre_idCompoundUniqueInput {
  genre_id: Int!
  movie_id: Int!
}

input MovieGenresOrderByRelationAggregateInput {
  _count: SortOrder
}

input MovieGenresOrderByWithAggregationInput {
  _avg: MovieGenresAvgOrderByAggregateInput
  _count: MovieGenresCountOrderByAggregateInput
  _max: MovieGenresMaxOrderByAggregateInput
  _min: MovieGenresMinOrderByAggregateInput
  _sum: MovieGenresSumOrderByAggregateInput
  genre_id: SortOrder
  movie_id: SortOrder
}

input MovieGenresOrderByWithRelationInput {
  Genres: GenresOrderByWithRelationInput
  Movies: MoviesOrderByWithRelationInput
  genre_id: SortOrder
  movie_id: SortOrder
}

enum MovieGenresScalarFieldEnum {
  genre_id
  movie_id
}

input MovieGenresScalarWhereInput {
  AND: [MovieGenresScalarWhereInput!]
  NOT: [MovieGenresScalarWhereInput!]
  OR: [MovieGenresScalarWhereInput!]
  genre_id: IntFilter
  movie_id: IntFilter
}

input MovieGenresScalarWhereWithAggregatesInput {
  AND: [MovieGenresScalarWhereWithAggregatesInput!]
  NOT: [MovieGenresScalarWhereWithAggregatesInput!]
  OR: [MovieGenresScalarWhereWithAggregatesInput!]
  genre_id: IntWithAggregatesFilter
  movie_id: IntWithAggregatesFilter
}

type MovieGenresSumAggregate {
  genre_id: Int
  movie_id: Int
}

input MovieGenresSumOrderByAggregateInput {
  genre_id: SortOrder
  movie_id: SortOrder
}

input MovieGenresUpdateInput {
  Genres: GenresUpdateOneRequiredWithoutMovieGenresNestedInput
  Movies: MoviesUpdateOneRequiredWithoutMovieGenresNestedInput
}

input MovieGenresUpdateManyWithWhereWithoutGenresInput {
  where: MovieGenresScalarWhereInput!
}

input MovieGenresUpdateManyWithWhereWithoutMoviesInput {
  where: MovieGenresScalarWhereInput!
}

input MovieGenresUpdateManyWithoutGenresNestedInput {
  connect: [MovieGenresWhereUniqueInput!]
  connectOrCreate: [MovieGenresCreateOrConnectWithoutGenresInput!]
  create: [MovieGenresCreateWithoutGenresInput!]
  createMany: MovieGenresCreateManyGenresInputEnvelope
  delete: [MovieGenresWhereUniqueInput!]
  deleteMany: [MovieGenresScalarWhereInput!]
  disconnect: [MovieGenresWhereUniqueInput!]
  set: [MovieGenresWhereUniqueInput!]
  update: [MovieGenresUpdateWithWhereUniqueWithoutGenresInput!]
  updateMany: [MovieGenresUpdateManyWithWhereWithoutGenresInput!]
  upsert: [MovieGenresUpsertWithWhereUniqueWithoutGenresInput!]
}

input MovieGenresUpdateManyWithoutMoviesNestedInput {
  connect: [MovieGenresWhereUniqueInput!]
  connectOrCreate: [MovieGenresCreateOrConnectWithoutMoviesInput!]
  create: [MovieGenresCreateWithoutMoviesInput!]
  createMany: MovieGenresCreateManyMoviesInputEnvelope
  delete: [MovieGenresWhereUniqueInput!]
  deleteMany: [MovieGenresScalarWhereInput!]
  disconnect: [MovieGenresWhereUniqueInput!]
  set: [MovieGenresWhereUniqueInput!]
  update: [MovieGenresUpdateWithWhereUniqueWithoutMoviesInput!]
  updateMany: [MovieGenresUpdateManyWithWhereWithoutMoviesInput!]
  upsert: [MovieGenresUpsertWithWhereUniqueWithoutMoviesInput!]
}

input MovieGenresUpdateWithWhereUniqueWithoutGenresInput {
  data: MovieGenresUpdateWithoutGenresInput!
  where: MovieGenresWhereUniqueInput!
}

input MovieGenresUpdateWithWhereUniqueWithoutMoviesInput {
  data: MovieGenresUpdateWithoutMoviesInput!
  where: MovieGenresWhereUniqueInput!
}

input MovieGenresUpdateWithoutGenresInput {
  Movies: MoviesUpdateOneRequiredWithoutMovieGenresNestedInput
}

input MovieGenresUpdateWithoutMoviesInput {
  Genres: GenresUpdateOneRequiredWithoutMovieGenresNestedInput
}

input MovieGenresUpsertWithWhereUniqueWithoutGenresInput {
  create: MovieGenresCreateWithoutGenresInput!
  update: MovieGenresUpdateWithoutGenresInput!
  where: MovieGenresWhereUniqueInput!
}

input MovieGenresUpsertWithWhereUniqueWithoutMoviesInput {
  create: MovieGenresCreateWithoutMoviesInput!
  update: MovieGenresUpdateWithoutMoviesInput!
  where: MovieGenresWhereUniqueInput!
}

input MovieGenresWhereInput {
  AND: [MovieGenresWhereInput!]
  Genres: GenresRelationFilter
  Movies: MoviesRelationFilter
  NOT: [MovieGenresWhereInput!]
  OR: [MovieGenresWhereInput!]
  genre_id: IntFilter
  movie_id: IntFilter
}

input MovieGenresWhereUniqueInput {
  movie_id_genre_id: MovieGenresMovie_idGenre_idCompoundUniqueInput
}

type Movies {
  MovieGenres(cursor: MovieGenresWhereUniqueInput, distinct: [MovieGenresScalarFieldEnum!], orderBy: [MovieGenresOrderByWithRelationInput!], skip: Int, take: Int, where: MovieGenresWhereInput): [MovieGenres!]!
  Ratings(cursor: RatingsWhereUniqueInput, distinct: [RatingsScalarFieldEnum!], orderBy: [RatingsOrderByWithRelationInput!], skip: Int, take: Int, where: RatingsWhereInput): [Ratings!]!
  _count: MoviesCount
  backdrop_path: String
  id: Int!
  overview: String
  popularity: Decimal
  poster_path: String
  release_date: DateTime
  runtime: Int
  title: String
  vote_average: Decimal
  vote_count: Int
}

type MoviesAvgAggregate {
  id: Float
  popularity: Decimal
  runtime: Float
  vote_average: Decimal
  vote_count: Float
}

input MoviesAvgOrderByAggregateInput {
  id: SortOrder
  popularity: SortOrder
  runtime: SortOrder
  vote_average: SortOrder
  vote_count: SortOrder
}

type MoviesCount {
  MovieGenres(where: MovieGenresWhereInput): Int!
  Ratings(where: RatingsWhereInput): Int!
}

type MoviesCountAggregate {
  _all: Int!
  backdrop_path: Int!
  id: Int!
  overview: Int!
  popularity: Int!
  poster_path: Int!
  release_date: Int!
  runtime: Int!
  title: Int!
  vote_average: Int!
  vote_count: Int!
}

input MoviesCountOrderByAggregateInput {
  backdrop_path: SortOrder
  id: SortOrder
  overview: SortOrder
  popularity: SortOrder
  poster_path: SortOrder
  release_date: SortOrder
  runtime: SortOrder
  title: SortOrder
  vote_average: SortOrder
  vote_count: SortOrder
}

input MoviesCreateInput {
  MovieGenres: MovieGenresCreateNestedManyWithoutMoviesInput
  Ratings: RatingsCreateNestedManyWithoutMoviesInput
  backdrop_path: String
  id: Int!
  overview: String
  popularity: Decimal
  poster_path: String
  release_date: DateTime
  runtime: Int
  title: String
  vote_average: Decimal
  vote_count: Int
}

input MoviesCreateManyInput {
  backdrop_path: String
  id: Int!
  overview: String
  popularity: Decimal
  poster_path: String
  release_date: DateTime
  runtime: Int
  title: String
  vote_average: Decimal
  vote_count: Int
}

input MoviesCreateNestedOneWithoutMovieGenresInput {
  connect: MoviesWhereUniqueInput
  connectOrCreate: MoviesCreateOrConnectWithoutMovieGenresInput
  create: MoviesCreateWithoutMovieGenresInput
}

input MoviesCreateNestedOneWithoutRatingsInput {
  connect: MoviesWhereUniqueInput
  connectOrCreate: MoviesCreateOrConnectWithoutRatingsInput
  create: MoviesCreateWithoutRatingsInput
}

input MoviesCreateOrConnectWithoutMovieGenresInput {
  create: MoviesCreateWithoutMovieGenresInput!
  where: MoviesWhereUniqueInput!
}

input MoviesCreateOrConnectWithoutRatingsInput {
  create: MoviesCreateWithoutRatingsInput!
  where: MoviesWhereUniqueInput!
}

input MoviesCreateWithoutMovieGenresInput {
  Ratings: RatingsCreateNestedManyWithoutMoviesInput
  backdrop_path: String
  id: Int!
  overview: String
  popularity: Decimal
  poster_path: String
  release_date: DateTime
  runtime: Int
  title: String
  vote_average: Decimal
  vote_count: Int
}

input MoviesCreateWithoutRatingsInput {
  MovieGenres: MovieGenresCreateNestedManyWithoutMoviesInput
  backdrop_path: String
  id: Int!
  overview: String
  popularity: Decimal
  poster_path: String
  release_date: DateTime
  runtime: Int
  title: String
  vote_average: Decimal
  vote_count: Int
}

type MoviesGroupBy {
  _avg: MoviesAvgAggregate
  _count: MoviesCountAggregate
  _max: MoviesMaxAggregate
  _min: MoviesMinAggregate
  _sum: MoviesSumAggregate
  backdrop_path: String
  id: Int!
  overview: String
  popularity: Decimal
  poster_path: String
  release_date: DateTime
  runtime: Int
  title: String
  vote_average: Decimal
  vote_count: Int
}

type MoviesMaxAggregate {
  backdrop_path: String
  id: Int
  overview: String
  popularity: Decimal
  poster_path: String
  release_date: DateTime
  runtime: Int
  title: String
  vote_average: Decimal
  vote_count: Int
}

input MoviesMaxOrderByAggregateInput {
  backdrop_path: SortOrder
  id: SortOrder
  overview: SortOrder
  popularity: SortOrder
  poster_path: SortOrder
  release_date: SortOrder
  runtime: SortOrder
  title: SortOrder
  vote_average: SortOrder
  vote_count: SortOrder
}

type MoviesMinAggregate {
  backdrop_path: String
  id: Int
  overview: String
  popularity: Decimal
  poster_path: String
  release_date: DateTime
  runtime: Int
  title: String
  vote_average: Decimal
  vote_count: Int
}

input MoviesMinOrderByAggregateInput {
  backdrop_path: SortOrder
  id: SortOrder
  overview: SortOrder
  popularity: SortOrder
  poster_path: SortOrder
  release_date: SortOrder
  runtime: SortOrder
  title: SortOrder
  vote_average: SortOrder
  vote_count: SortOrder
}

input MoviesOrderByWithAggregationInput {
  _avg: MoviesAvgOrderByAggregateInput
  _count: MoviesCountOrderByAggregateInput
  _max: MoviesMaxOrderByAggregateInput
  _min: MoviesMinOrderByAggregateInput
  _sum: MoviesSumOrderByAggregateInput
  backdrop_path: SortOrderInput
  id: SortOrder
  overview: SortOrderInput
  popularity: SortOrderInput
  poster_path: SortOrderInput
  release_date: SortOrderInput
  runtime: SortOrderInput
  title: SortOrderInput
  vote_average: SortOrderInput
  vote_count: SortOrderInput
}

input MoviesOrderByWithRelationInput {
  MovieGenres: MovieGenresOrderByRelationAggregateInput
  Ratings: RatingsOrderByRelationAggregateInput
  backdrop_path: SortOrderInput
  id: SortOrder
  overview: SortOrderInput
  popularity: SortOrderInput
  poster_path: SortOrderInput
  release_date: SortOrderInput
  runtime: SortOrderInput
  title: SortOrderInput
  vote_average: SortOrderInput
  vote_count: SortOrderInput
}

input MoviesRelationFilter {
  is: MoviesWhereInput
  isNot: MoviesWhereInput
}

enum MoviesScalarFieldEnum {
  backdrop_path
  id
  overview
  popularity
  poster_path
  release_date
  runtime
  title
  vote_average
  vote_count
}

input MoviesScalarWhereWithAggregatesInput {
  AND: [MoviesScalarWhereWithAggregatesInput!]
  NOT: [MoviesScalarWhereWithAggregatesInput!]
  OR: [MoviesScalarWhereWithAggregatesInput!]
  backdrop_path: StringNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  overview: StringNullableWithAggregatesFilter
  popularity: DecimalNullableWithAggregatesFilter
  poster_path: StringNullableWithAggregatesFilter
  release_date: DateTimeNullableWithAggregatesFilter
  runtime: IntNullableWithAggregatesFilter
  title: StringNullableWithAggregatesFilter
  vote_average: DecimalNullableWithAggregatesFilter
  vote_count: IntNullableWithAggregatesFilter
}

type MoviesSumAggregate {
  id: Int
  popularity: Decimal
  runtime: Int
  vote_average: Decimal
  vote_count: Int
}

input MoviesSumOrderByAggregateInput {
  id: SortOrder
  popularity: SortOrder
  runtime: SortOrder
  vote_average: SortOrder
  vote_count: SortOrder
}

input MoviesUpdateInput {
  MovieGenres: MovieGenresUpdateManyWithoutMoviesNestedInput
  Ratings: RatingsUpdateManyWithoutMoviesNestedInput
  backdrop_path: NullableStringFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  overview: NullableStringFieldUpdateOperationsInput
  popularity: NullableDecimalFieldUpdateOperationsInput
  poster_path: NullableStringFieldUpdateOperationsInput
  release_date: NullableDateTimeFieldUpdateOperationsInput
  runtime: NullableIntFieldUpdateOperationsInput
  title: NullableStringFieldUpdateOperationsInput
  vote_average: NullableDecimalFieldUpdateOperationsInput
  vote_count: NullableIntFieldUpdateOperationsInput
}

input MoviesUpdateManyMutationInput {
  backdrop_path: NullableStringFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  overview: NullableStringFieldUpdateOperationsInput
  popularity: NullableDecimalFieldUpdateOperationsInput
  poster_path: NullableStringFieldUpdateOperationsInput
  release_date: NullableDateTimeFieldUpdateOperationsInput
  runtime: NullableIntFieldUpdateOperationsInput
  title: NullableStringFieldUpdateOperationsInput
  vote_average: NullableDecimalFieldUpdateOperationsInput
  vote_count: NullableIntFieldUpdateOperationsInput
}

input MoviesUpdateOneRequiredWithoutMovieGenresNestedInput {
  connect: MoviesWhereUniqueInput
  connectOrCreate: MoviesCreateOrConnectWithoutMovieGenresInput
  create: MoviesCreateWithoutMovieGenresInput
  update: MoviesUpdateWithoutMovieGenresInput
  upsert: MoviesUpsertWithoutMovieGenresInput
}

input MoviesUpdateOneRequiredWithoutRatingsNestedInput {
  connect: MoviesWhereUniqueInput
  connectOrCreate: MoviesCreateOrConnectWithoutRatingsInput
  create: MoviesCreateWithoutRatingsInput
  update: MoviesUpdateWithoutRatingsInput
  upsert: MoviesUpsertWithoutRatingsInput
}

input MoviesUpdateWithoutMovieGenresInput {
  Ratings: RatingsUpdateManyWithoutMoviesNestedInput
  backdrop_path: NullableStringFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  overview: NullableStringFieldUpdateOperationsInput
  popularity: NullableDecimalFieldUpdateOperationsInput
  poster_path: NullableStringFieldUpdateOperationsInput
  release_date: NullableDateTimeFieldUpdateOperationsInput
  runtime: NullableIntFieldUpdateOperationsInput
  title: NullableStringFieldUpdateOperationsInput
  vote_average: NullableDecimalFieldUpdateOperationsInput
  vote_count: NullableIntFieldUpdateOperationsInput
}

input MoviesUpdateWithoutRatingsInput {
  MovieGenres: MovieGenresUpdateManyWithoutMoviesNestedInput
  backdrop_path: NullableStringFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  overview: NullableStringFieldUpdateOperationsInput
  popularity: NullableDecimalFieldUpdateOperationsInput
  poster_path: NullableStringFieldUpdateOperationsInput
  release_date: NullableDateTimeFieldUpdateOperationsInput
  runtime: NullableIntFieldUpdateOperationsInput
  title: NullableStringFieldUpdateOperationsInput
  vote_average: NullableDecimalFieldUpdateOperationsInput
  vote_count: NullableIntFieldUpdateOperationsInput
}

input MoviesUpsertWithoutMovieGenresInput {
  create: MoviesCreateWithoutMovieGenresInput!
  update: MoviesUpdateWithoutMovieGenresInput!
}

input MoviesUpsertWithoutRatingsInput {
  create: MoviesCreateWithoutRatingsInput!
  update: MoviesUpdateWithoutRatingsInput!
}

input MoviesWhereInput {
  AND: [MoviesWhereInput!]
  MovieGenres: MovieGenresListRelationFilter
  NOT: [MoviesWhereInput!]
  OR: [MoviesWhereInput!]
  Ratings: RatingsListRelationFilter
  backdrop_path: StringNullableFilter
  id: IntFilter
  overview: StringNullableFilter
  popularity: DecimalNullableFilter
  poster_path: StringNullableFilter
  release_date: DateTimeNullableFilter
  runtime: IntNullableFilter
  title: StringNullableFilter
  vote_average: DecimalNullableFilter
  vote_count: IntNullableFilter
}

input MoviesWhereUniqueInput {
  id: Int
}

type Mutation {
  createManyGenres(data: [GenresCreateManyInput!]!): AffectedRowsOutput!
  createManyMovieGenres(data: [MovieGenresCreateManyInput!]!): AffectedRowsOutput!
  createManyMovies(data: [MoviesCreateManyInput!]!): AffectedRowsOutput!
  createManyRatings(data: [RatingsCreateManyInput!]!): AffectedRowsOutput!
  createManyUsers(data: [UsersCreateManyInput!]!): AffectedRowsOutput!
  createOneGenres(data: GenresCreateInput!): Genres!
  createOneMovieGenres(data: MovieGenresCreateInput!): MovieGenres!
  createOneMovies(data: MoviesCreateInput!): Movies!
  createOneRatings(data: RatingsCreateInput!): Ratings!
  createOneUsers(data: UsersCreateInput!): Users!
  deleteManyGenres(where: GenresWhereInput): AffectedRowsOutput!
  deleteManyMovieGenres(where: MovieGenresWhereInput): AffectedRowsOutput!
  deleteManyMovies(where: MoviesWhereInput): AffectedRowsOutput!
  deleteManyRatings(where: RatingsWhereInput): AffectedRowsOutput!
  deleteManyUsers(where: UsersWhereInput): AffectedRowsOutput!
  deleteOneGenres(where: GenresWhereUniqueInput!): Genres
  deleteOneMovieGenres(where: MovieGenresWhereUniqueInput!): MovieGenres
  deleteOneMovies(where: MoviesWhereUniqueInput!): Movies
  deleteOneRatings(where: RatingsWhereUniqueInput!): Ratings
  deleteOneUsers(where: UsersWhereUniqueInput!): Users
  updateManyGenres(data: GenresUpdateManyMutationInput!, where: GenresWhereInput): AffectedRowsOutput!
  updateManyMovieGenres(where: MovieGenresWhereInput): AffectedRowsOutput!
  updateManyMovies(data: MoviesUpdateManyMutationInput!, where: MoviesWhereInput): AffectedRowsOutput!
  updateManyRatings(data: RatingsUpdateManyMutationInput!, where: RatingsWhereInput): AffectedRowsOutput!
  updateManyUsers(data: UsersUpdateManyMutationInput!, where: UsersWhereInput): AffectedRowsOutput!
  updateOneGenres(data: GenresUpdateInput!, where: GenresWhereUniqueInput!): Genres
  updateOneMovieGenres(data: MovieGenresUpdateInput!, where: MovieGenresWhereUniqueInput!): MovieGenres
  updateOneMovies(data: MoviesUpdateInput!, where: MoviesWhereUniqueInput!): Movies
  updateOneRatings(data: RatingsUpdateInput!, where: RatingsWhereUniqueInput!): Ratings
  updateOneUsers(data: UsersUpdateInput!, where: UsersWhereUniqueInput!): Users
  upsertOneGenres(create: GenresCreateInput!, update: GenresUpdateInput!, where: GenresWhereUniqueInput!): Genres!
  upsertOneMovieGenres(create: MovieGenresCreateInput!, update: MovieGenresUpdateInput!, where: MovieGenresWhereUniqueInput!): MovieGenres!
  upsertOneMovies(create: MoviesCreateInput!, update: MoviesUpdateInput!, where: MoviesWhereUniqueInput!): Movies!
  upsertOneRatings(create: RatingsCreateInput!, update: RatingsUpdateInput!, where: RatingsWhereUniqueInput!): Ratings!
  upsertOneUsers(create: UsersCreateInput!, update: UsersUpdateInput!, where: UsersWhereUniqueInput!): Users!
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedDecimalNullableFilter {
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalNullableFilter
  notIn: [Decimal!]
}

input NestedDecimalNullableWithAggregatesFilter {
  _avg: NestedDecimalNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedDecimalNullableFilter
  _min: NestedDecimalNullableFilter
  _sum: NestedDecimalNullableFilter
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalNullableWithAggregatesFilter
  notIn: [Decimal!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input NestedFloatWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedFloatFilter
  _min: NestedFloatFilter
  _sum: NestedFloatFilter
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatWithAggregatesFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NullableDateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input NullableDecimalFieldUpdateOperationsInput {
  decrement: Decimal
  divide: Decimal
  increment: Decimal
  multiply: Decimal
  set: Decimal
}

input NullableIntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

enum NullsOrder {
  first
  last
}

type Query {
  aggregateGenres(cursor: GenresWhereUniqueInput, orderBy: [GenresOrderByWithRelationInput!], skip: Int, take: Int, where: GenresWhereInput): AggregateGenres!
  aggregateMovieGenres(cursor: MovieGenresWhereUniqueInput, orderBy: [MovieGenresOrderByWithRelationInput!], skip: Int, take: Int, where: MovieGenresWhereInput): AggregateMovieGenres!
  aggregateMovies(cursor: MoviesWhereUniqueInput, orderBy: [MoviesOrderByWithRelationInput!], skip: Int, take: Int, where: MoviesWhereInput): AggregateMovies!
  aggregateRatings(cursor: RatingsWhereUniqueInput, orderBy: [RatingsOrderByWithRelationInput!], skip: Int, take: Int, where: RatingsWhereInput): AggregateRatings!
  aggregateUsers(cursor: UsersWhereUniqueInput, orderBy: [UsersOrderByWithRelationInput!], skip: Int, take: Int, where: UsersWhereInput): AggregateUsers!
  findFirstGenres(cursor: GenresWhereUniqueInput, distinct: [GenresScalarFieldEnum!], orderBy: [GenresOrderByWithRelationInput!], skip: Int, take: Int, where: GenresWhereInput): Genres
  findFirstGenresOrThrow(cursor: GenresWhereUniqueInput, distinct: [GenresScalarFieldEnum!], orderBy: [GenresOrderByWithRelationInput!], skip: Int, take: Int, where: GenresWhereInput): Genres
  findFirstMovieGenres(cursor: MovieGenresWhereUniqueInput, distinct: [MovieGenresScalarFieldEnum!], orderBy: [MovieGenresOrderByWithRelationInput!], skip: Int, take: Int, where: MovieGenresWhereInput): MovieGenres
  findFirstMovieGenresOrThrow(cursor: MovieGenresWhereUniqueInput, distinct: [MovieGenresScalarFieldEnum!], orderBy: [MovieGenresOrderByWithRelationInput!], skip: Int, take: Int, where: MovieGenresWhereInput): MovieGenres
  findFirstMovies(cursor: MoviesWhereUniqueInput, distinct: [MoviesScalarFieldEnum!], orderBy: [MoviesOrderByWithRelationInput!], skip: Int, take: Int, where: MoviesWhereInput): Movies
  findFirstMoviesOrThrow(cursor: MoviesWhereUniqueInput, distinct: [MoviesScalarFieldEnum!], orderBy: [MoviesOrderByWithRelationInput!], skip: Int, take: Int, where: MoviesWhereInput): Movies
  findFirstRatings(cursor: RatingsWhereUniqueInput, distinct: [RatingsScalarFieldEnum!], orderBy: [RatingsOrderByWithRelationInput!], skip: Int, take: Int, where: RatingsWhereInput): Ratings
  findFirstRatingsOrThrow(cursor: RatingsWhereUniqueInput, distinct: [RatingsScalarFieldEnum!], orderBy: [RatingsOrderByWithRelationInput!], skip: Int, take: Int, where: RatingsWhereInput): Ratings
  findFirstUsers(cursor: UsersWhereUniqueInput, distinct: [UsersScalarFieldEnum!], orderBy: [UsersOrderByWithRelationInput!], skip: Int, take: Int, where: UsersWhereInput): Users
  findFirstUsersOrThrow(cursor: UsersWhereUniqueInput, distinct: [UsersScalarFieldEnum!], orderBy: [UsersOrderByWithRelationInput!], skip: Int, take: Int, where: UsersWhereInput): Users
  findManyGenres(cursor: GenresWhereUniqueInput, distinct: [GenresScalarFieldEnum!], orderBy: [GenresOrderByWithRelationInput!], skip: Int, take: Int, where: GenresWhereInput): [Genres!]!
  findManyMovieGenres(cursor: MovieGenresWhereUniqueInput, distinct: [MovieGenresScalarFieldEnum!], orderBy: [MovieGenresOrderByWithRelationInput!], skip: Int, take: Int, where: MovieGenresWhereInput): [MovieGenres!]!
  findManyMovies(cursor: MoviesWhereUniqueInput, distinct: [MoviesScalarFieldEnum!], orderBy: [MoviesOrderByWithRelationInput!], skip: Int, take: Int, where: MoviesWhereInput): [Movies!]!
  findManyRatings(cursor: RatingsWhereUniqueInput, distinct: [RatingsScalarFieldEnum!], orderBy: [RatingsOrderByWithRelationInput!], skip: Int, take: Int, where: RatingsWhereInput): [Ratings!]!
  findManyUsers(cursor: UsersWhereUniqueInput, distinct: [UsersScalarFieldEnum!], orderBy: [UsersOrderByWithRelationInput!], skip: Int, take: Int, where: UsersWhereInput): [Users!]!
  findUniqueGenres(where: GenresWhereUniqueInput!): Genres
  findUniqueGenresOrThrow(where: GenresWhereUniqueInput!): Genres
  findUniqueMovieGenres(where: MovieGenresWhereUniqueInput!): MovieGenres
  findUniqueMovieGenresOrThrow(where: MovieGenresWhereUniqueInput!): MovieGenres
  findUniqueMovies(where: MoviesWhereUniqueInput!): Movies
  findUniqueMoviesOrThrow(where: MoviesWhereUniqueInput!): Movies
  findUniqueRatings(where: RatingsWhereUniqueInput!): Ratings
  findUniqueRatingsOrThrow(where: RatingsWhereUniqueInput!): Ratings
  findUniqueUsers(where: UsersWhereUniqueInput!): Users
  findUniqueUsersOrThrow(where: UsersWhereUniqueInput!): Users
  groupByGenres(by: [GenresScalarFieldEnum!]!, having: GenresScalarWhereWithAggregatesInput, orderBy: [GenresOrderByWithAggregationInput!], skip: Int, take: Int, where: GenresWhereInput): [GenresGroupBy!]!
  groupByMovieGenres(by: [MovieGenresScalarFieldEnum!]!, having: MovieGenresScalarWhereWithAggregatesInput, orderBy: [MovieGenresOrderByWithAggregationInput!], skip: Int, take: Int, where: MovieGenresWhereInput): [MovieGenresGroupBy!]!
  groupByMovies(by: [MoviesScalarFieldEnum!]!, having: MoviesScalarWhereWithAggregatesInput, orderBy: [MoviesOrderByWithAggregationInput!], skip: Int, take: Int, where: MoviesWhereInput): [MoviesGroupBy!]!
  groupByRatings(by: [RatingsScalarFieldEnum!]!, having: RatingsScalarWhereWithAggregatesInput, orderBy: [RatingsOrderByWithAggregationInput!], skip: Int, take: Int, where: RatingsWhereInput): [RatingsGroupBy!]!
  groupByUsers(by: [UsersScalarFieldEnum!]!, having: UsersScalarWhereWithAggregatesInput, orderBy: [UsersOrderByWithAggregationInput!], skip: Int, take: Int, where: UsersWhereInput): [UsersGroupBy!]!
}

type Ratings {
  Movies: Movies!
  Users: Users!
  movie_id: Int!
  rating: Float!
  user_id: Int!
}

type RatingsAvgAggregate {
  movie_id: Float
  rating: Float
  user_id: Float
}

input RatingsAvgOrderByAggregateInput {
  movie_id: SortOrder
  rating: SortOrder
  user_id: SortOrder
}

type RatingsCountAggregate {
  _all: Int!
  movie_id: Int!
  rating: Int!
  user_id: Int!
}

input RatingsCountOrderByAggregateInput {
  movie_id: SortOrder
  rating: SortOrder
  user_id: SortOrder
}

input RatingsCreateInput {
  Movies: MoviesCreateNestedOneWithoutRatingsInput!
  Users: UsersCreateNestedOneWithoutRatingsInput!
  rating: Float!
}

input RatingsCreateManyInput {
  movie_id: Int!
  rating: Float!
  user_id: Int!
}

input RatingsCreateManyMoviesInput {
  rating: Float!
  user_id: Int!
}

input RatingsCreateManyMoviesInputEnvelope {
  data: [RatingsCreateManyMoviesInput!]!
}

input RatingsCreateManyUsersInput {
  movie_id: Int!
  rating: Float!
}

input RatingsCreateManyUsersInputEnvelope {
  data: [RatingsCreateManyUsersInput!]!
}

input RatingsCreateNestedManyWithoutMoviesInput {
  connect: [RatingsWhereUniqueInput!]
  connectOrCreate: [RatingsCreateOrConnectWithoutMoviesInput!]
  create: [RatingsCreateWithoutMoviesInput!]
  createMany: RatingsCreateManyMoviesInputEnvelope
}

input RatingsCreateNestedManyWithoutUsersInput {
  connect: [RatingsWhereUniqueInput!]
  connectOrCreate: [RatingsCreateOrConnectWithoutUsersInput!]
  create: [RatingsCreateWithoutUsersInput!]
  createMany: RatingsCreateManyUsersInputEnvelope
}

input RatingsCreateOrConnectWithoutMoviesInput {
  create: RatingsCreateWithoutMoviesInput!
  where: RatingsWhereUniqueInput!
}

input RatingsCreateOrConnectWithoutUsersInput {
  create: RatingsCreateWithoutUsersInput!
  where: RatingsWhereUniqueInput!
}

input RatingsCreateWithoutMoviesInput {
  Users: UsersCreateNestedOneWithoutRatingsInput!
  rating: Float!
}

input RatingsCreateWithoutUsersInput {
  Movies: MoviesCreateNestedOneWithoutRatingsInput!
  rating: Float!
}

type RatingsGroupBy {
  _avg: RatingsAvgAggregate
  _count: RatingsCountAggregate
  _max: RatingsMaxAggregate
  _min: RatingsMinAggregate
  _sum: RatingsSumAggregate
  movie_id: Int!
  rating: Float!
  user_id: Int!
}

input RatingsListRelationFilter {
  every: RatingsWhereInput
  none: RatingsWhereInput
  some: RatingsWhereInput
}

type RatingsMaxAggregate {
  movie_id: Int
  rating: Float
  user_id: Int
}

input RatingsMaxOrderByAggregateInput {
  movie_id: SortOrder
  rating: SortOrder
  user_id: SortOrder
}

type RatingsMinAggregate {
  movie_id: Int
  rating: Float
  user_id: Int
}

input RatingsMinOrderByAggregateInput {
  movie_id: SortOrder
  rating: SortOrder
  user_id: SortOrder
}

input RatingsOrderByRelationAggregateInput {
  _count: SortOrder
}

input RatingsOrderByWithAggregationInput {
  _avg: RatingsAvgOrderByAggregateInput
  _count: RatingsCountOrderByAggregateInput
  _max: RatingsMaxOrderByAggregateInput
  _min: RatingsMinOrderByAggregateInput
  _sum: RatingsSumOrderByAggregateInput
  movie_id: SortOrder
  rating: SortOrder
  user_id: SortOrder
}

input RatingsOrderByWithRelationInput {
  Movies: MoviesOrderByWithRelationInput
  Users: UsersOrderByWithRelationInput
  movie_id: SortOrder
  rating: SortOrder
  user_id: SortOrder
}

enum RatingsScalarFieldEnum {
  movie_id
  rating
  user_id
}

input RatingsScalarWhereInput {
  AND: [RatingsScalarWhereInput!]
  NOT: [RatingsScalarWhereInput!]
  OR: [RatingsScalarWhereInput!]
  movie_id: IntFilter
  rating: FloatFilter
  user_id: IntFilter
}

input RatingsScalarWhereWithAggregatesInput {
  AND: [RatingsScalarWhereWithAggregatesInput!]
  NOT: [RatingsScalarWhereWithAggregatesInput!]
  OR: [RatingsScalarWhereWithAggregatesInput!]
  movie_id: IntWithAggregatesFilter
  rating: FloatWithAggregatesFilter
  user_id: IntWithAggregatesFilter
}

type RatingsSumAggregate {
  movie_id: Int
  rating: Float
  user_id: Int
}

input RatingsSumOrderByAggregateInput {
  movie_id: SortOrder
  rating: SortOrder
  user_id: SortOrder
}

input RatingsUpdateInput {
  Movies: MoviesUpdateOneRequiredWithoutRatingsNestedInput
  Users: UsersUpdateOneRequiredWithoutRatingsNestedInput
  rating: FloatFieldUpdateOperationsInput
}

input RatingsUpdateManyMutationInput {
  rating: FloatFieldUpdateOperationsInput
}

input RatingsUpdateManyWithWhereWithoutMoviesInput {
  data: RatingsUpdateManyMutationInput!
  where: RatingsScalarWhereInput!
}

input RatingsUpdateManyWithWhereWithoutUsersInput {
  data: RatingsUpdateManyMutationInput!
  where: RatingsScalarWhereInput!
}

input RatingsUpdateManyWithoutMoviesNestedInput {
  connect: [RatingsWhereUniqueInput!]
  connectOrCreate: [RatingsCreateOrConnectWithoutMoviesInput!]
  create: [RatingsCreateWithoutMoviesInput!]
  createMany: RatingsCreateManyMoviesInputEnvelope
  delete: [RatingsWhereUniqueInput!]
  deleteMany: [RatingsScalarWhereInput!]
  disconnect: [RatingsWhereUniqueInput!]
  set: [RatingsWhereUniqueInput!]
  update: [RatingsUpdateWithWhereUniqueWithoutMoviesInput!]
  updateMany: [RatingsUpdateManyWithWhereWithoutMoviesInput!]
  upsert: [RatingsUpsertWithWhereUniqueWithoutMoviesInput!]
}

input RatingsUpdateManyWithoutUsersNestedInput {
  connect: [RatingsWhereUniqueInput!]
  connectOrCreate: [RatingsCreateOrConnectWithoutUsersInput!]
  create: [RatingsCreateWithoutUsersInput!]
  createMany: RatingsCreateManyUsersInputEnvelope
  delete: [RatingsWhereUniqueInput!]
  deleteMany: [RatingsScalarWhereInput!]
  disconnect: [RatingsWhereUniqueInput!]
  set: [RatingsWhereUniqueInput!]
  update: [RatingsUpdateWithWhereUniqueWithoutUsersInput!]
  updateMany: [RatingsUpdateManyWithWhereWithoutUsersInput!]
  upsert: [RatingsUpsertWithWhereUniqueWithoutUsersInput!]
}

input RatingsUpdateWithWhereUniqueWithoutMoviesInput {
  data: RatingsUpdateWithoutMoviesInput!
  where: RatingsWhereUniqueInput!
}

input RatingsUpdateWithWhereUniqueWithoutUsersInput {
  data: RatingsUpdateWithoutUsersInput!
  where: RatingsWhereUniqueInput!
}

input RatingsUpdateWithoutMoviesInput {
  Users: UsersUpdateOneRequiredWithoutRatingsNestedInput
  rating: FloatFieldUpdateOperationsInput
}

input RatingsUpdateWithoutUsersInput {
  Movies: MoviesUpdateOneRequiredWithoutRatingsNestedInput
  rating: FloatFieldUpdateOperationsInput
}

input RatingsUpsertWithWhereUniqueWithoutMoviesInput {
  create: RatingsCreateWithoutMoviesInput!
  update: RatingsUpdateWithoutMoviesInput!
  where: RatingsWhereUniqueInput!
}

input RatingsUpsertWithWhereUniqueWithoutUsersInput {
  create: RatingsCreateWithoutUsersInput!
  update: RatingsUpdateWithoutUsersInput!
  where: RatingsWhereUniqueInput!
}

input RatingsUser_idMovie_idCompoundUniqueInput {
  movie_id: Int!
  user_id: Int!
}

input RatingsWhereInput {
  AND: [RatingsWhereInput!]
  Movies: MoviesRelationFilter
  NOT: [RatingsWhereInput!]
  OR: [RatingsWhereInput!]
  Users: UsersRelationFilter
  movie_id: IntFilter
  rating: FloatFilter
  user_id: IntFilter
}

input RatingsWhereUniqueInput {
  user_id_movie_id: RatingsUser_idMovie_idCompoundUniqueInput
}

enum SortOrder {
  asc
  desc
}

input SortOrderInput {
  nulls: NullsOrder
  sort: SortOrder!
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Users {
  Ratings(cursor: RatingsWhereUniqueInput, distinct: [RatingsScalarFieldEnum!], orderBy: [RatingsOrderByWithRelationInput!], skip: Int, take: Int, where: RatingsWhereInput): [Ratings!]!
  _count: UsersCount
  id: Int!
  password: String!
  username: String!
}

type UsersAvgAggregate {
  id: Float
}

input UsersAvgOrderByAggregateInput {
  id: SortOrder
}

type UsersCount {
  Ratings(where: RatingsWhereInput): Int!
}

type UsersCountAggregate {
  _all: Int!
  id: Int!
  password: Int!
  username: Int!
}

input UsersCountOrderByAggregateInput {
  id: SortOrder
  password: SortOrder
  username: SortOrder
}

input UsersCreateInput {
  Ratings: RatingsCreateNestedManyWithoutUsersInput
  id: Int!
  password: String!
  username: String!
}

input UsersCreateManyInput {
  id: Int!
  password: String!
  username: String!
}

input UsersCreateNestedOneWithoutRatingsInput {
  connect: UsersWhereUniqueInput
  connectOrCreate: UsersCreateOrConnectWithoutRatingsInput
  create: UsersCreateWithoutRatingsInput
}

input UsersCreateOrConnectWithoutRatingsInput {
  create: UsersCreateWithoutRatingsInput!
  where: UsersWhereUniqueInput!
}

input UsersCreateWithoutRatingsInput {
  id: Int!
  password: String!
  username: String!
}

type UsersGroupBy {
  _avg: UsersAvgAggregate
  _count: UsersCountAggregate
  _max: UsersMaxAggregate
  _min: UsersMinAggregate
  _sum: UsersSumAggregate
  id: Int!
  password: String!
  username: String!
}

type UsersMaxAggregate {
  id: Int
  password: String
  username: String
}

input UsersMaxOrderByAggregateInput {
  id: SortOrder
  password: SortOrder
  username: SortOrder
}

type UsersMinAggregate {
  id: Int
  password: String
  username: String
}

input UsersMinOrderByAggregateInput {
  id: SortOrder
  password: SortOrder
  username: SortOrder
}

input UsersOrderByWithAggregationInput {
  _avg: UsersAvgOrderByAggregateInput
  _count: UsersCountOrderByAggregateInput
  _max: UsersMaxOrderByAggregateInput
  _min: UsersMinOrderByAggregateInput
  _sum: UsersSumOrderByAggregateInput
  id: SortOrder
  password: SortOrder
  username: SortOrder
}

input UsersOrderByWithRelationInput {
  Ratings: RatingsOrderByRelationAggregateInput
  id: SortOrder
  password: SortOrder
  username: SortOrder
}

input UsersRelationFilter {
  is: UsersWhereInput
  isNot: UsersWhereInput
}

enum UsersScalarFieldEnum {
  id
  password
  username
}

input UsersScalarWhereWithAggregatesInput {
  AND: [UsersScalarWhereWithAggregatesInput!]
  NOT: [UsersScalarWhereWithAggregatesInput!]
  OR: [UsersScalarWhereWithAggregatesInput!]
  id: IntWithAggregatesFilter
  password: StringWithAggregatesFilter
  username: StringWithAggregatesFilter
}

type UsersSumAggregate {
  id: Int
}

input UsersSumOrderByAggregateInput {
  id: SortOrder
}

input UsersUpdateInput {
  Ratings: RatingsUpdateManyWithoutUsersNestedInput
  id: IntFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  username: StringFieldUpdateOperationsInput
}

input UsersUpdateManyMutationInput {
  id: IntFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  username: StringFieldUpdateOperationsInput
}

input UsersUpdateOneRequiredWithoutRatingsNestedInput {
  connect: UsersWhereUniqueInput
  connectOrCreate: UsersCreateOrConnectWithoutRatingsInput
  create: UsersCreateWithoutRatingsInput
  update: UsersUpdateWithoutRatingsInput
  upsert: UsersUpsertWithoutRatingsInput
}

input UsersUpdateWithoutRatingsInput {
  id: IntFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  username: StringFieldUpdateOperationsInput
}

input UsersUpsertWithoutRatingsInput {
  create: UsersCreateWithoutRatingsInput!
  update: UsersUpdateWithoutRatingsInput!
}

input UsersWhereInput {
  AND: [UsersWhereInput!]
  NOT: [UsersWhereInput!]
  OR: [UsersWhereInput!]
  Ratings: RatingsListRelationFilter
  id: IntFilter
  password: StringFilter
  username: StringFilter
}

input UsersWhereUniqueInput {
  id: Int
}