# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateGenres {
  _avg: GenresAvgAggregate
  _count: GenresCountAggregate
  _max: GenresMaxAggregate
  _min: GenresMinAggregate
  _sum: GenresSumAggregate
}

type AggregateMovie_genres {
  _avg: Movie_genresAvgAggregate
  _count: Movie_genresCountAggregate
  _max: Movie_genresMaxAggregate
  _min: Movie_genresMinAggregate
  _sum: Movie_genresSumAggregate
}

type AggregateMovies {
  _avg: MoviesAvgAggregate
  _count: MoviesCountAggregate
  _max: MoviesMaxAggregate
  _min: MoviesMinAggregate
  _sum: MoviesSumAggregate
}

type AggregateRatings {
  _avg: RatingsAvgAggregate
  _count: RatingsCountAggregate
  _max: RatingsMaxAggregate
  _min: RatingsMinAggregate
  _sum: RatingsSumAggregate
}

type AggregateUsers {
  _avg: UsersAvgAggregate
  _count: UsersCountAggregate
  _max: UsersMaxAggregate
  _min: UsersMinAggregate
  _sum: UsersSumAggregate
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input DateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime!]
}

"""
GraphQL Scalar representing the Prisma.Decimal type, based on Decimal.js library.
"""
scalar Decimal

input DecimalNullableFilter {
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalNullableFilter
  notIn: [Decimal!]
}

input DecimalNullableWithAggregatesFilter {
  _avg: NestedDecimalNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedDecimalNullableFilter
  _min: NestedDecimalNullableFilter
  _sum: NestedDecimalNullableFilter
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalNullableWithAggregatesFilter
  notIn: [Decimal!]
}

input FloatFieldUpdateOperationsInput {
  decrement: Float
  divide: Float
  increment: Float
  multiply: Float
  set: Float
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input FloatWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedFloatFilter
  _min: NestedFloatFilter
  _sum: NestedFloatFilter
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatWithAggregatesFilter
  notIn: [Float!]
}

type Genres {
  _count: GenresCount
  genre: String!
  id: Int!
  movie_genres(cursor: Movie_genresWhereUniqueInput, distinct: [Movie_genresScalarFieldEnum!], orderBy: [Movie_genresOrderByWithRelationInput!], skip: Int, take: Int, where: Movie_genresWhereInput): [Movie_genres!]!
}

type GenresAvgAggregate {
  id: Float
}

input GenresAvgOrderByAggregateInput {
  id: SortOrder
}

type GenresCount {
  movie_genres(where: Movie_genresWhereInput): Int!
}

type GenresCountAggregate {
  _all: Int!
  genre: Int!
  id: Int!
}

input GenresCountOrderByAggregateInput {
  genre: SortOrder
  id: SortOrder
}

input GenresCreateInput {
  genre: String!
  movie_genres: Movie_genresCreateNestedManyWithoutGenresInput
}

input GenresCreateManyInput {
  genre: String!
  id: Int
}

input GenresCreateNestedOneWithoutMovie_genresInput {
  connect: GenresWhereUniqueInput
  connectOrCreate: GenresCreateOrConnectWithoutMovie_genresInput
  create: GenresCreateWithoutMovie_genresInput
}

input GenresCreateOrConnectWithoutMovie_genresInput {
  create: GenresCreateWithoutMovie_genresInput!
  where: GenresWhereUniqueInput!
}

input GenresCreateWithoutMovie_genresInput {
  genre: String!
}

type GenresGroupBy {
  _avg: GenresAvgAggregate
  _count: GenresCountAggregate
  _max: GenresMaxAggregate
  _min: GenresMinAggregate
  _sum: GenresSumAggregate
  genre: String!
  id: Int!
}

type GenresMaxAggregate {
  genre: String
  id: Int
}

input GenresMaxOrderByAggregateInput {
  genre: SortOrder
  id: SortOrder
}

type GenresMinAggregate {
  genre: String
  id: Int
}

input GenresMinOrderByAggregateInput {
  genre: SortOrder
  id: SortOrder
}

input GenresOrderByWithAggregationInput {
  _avg: GenresAvgOrderByAggregateInput
  _count: GenresCountOrderByAggregateInput
  _max: GenresMaxOrderByAggregateInput
  _min: GenresMinOrderByAggregateInput
  _sum: GenresSumOrderByAggregateInput
  genre: SortOrder
  id: SortOrder
}

input GenresOrderByWithRelationInput {
  genre: SortOrder
  id: SortOrder
  movie_genres: Movie_genresOrderByRelationAggregateInput
}

input GenresRelationFilter {
  is: GenresWhereInput
  isNot: GenresWhereInput
}

enum GenresScalarFieldEnum {
  genre
  id
}

input GenresScalarWhereWithAggregatesInput {
  AND: [GenresScalarWhereWithAggregatesInput!]
  NOT: [GenresScalarWhereWithAggregatesInput!]
  OR: [GenresScalarWhereWithAggregatesInput!]
  genre: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
}

type GenresSumAggregate {
  id: Int
}

input GenresSumOrderByAggregateInput {
  id: SortOrder
}

input GenresUpdateInput {
  genre: StringFieldUpdateOperationsInput
  movie_genres: Movie_genresUpdateManyWithoutGenresNestedInput
}

input GenresUpdateManyMutationInput {
  genre: StringFieldUpdateOperationsInput
}

input GenresUpdateOneRequiredWithoutMovie_genresNestedInput {
  connect: GenresWhereUniqueInput
  connectOrCreate: GenresCreateOrConnectWithoutMovie_genresInput
  create: GenresCreateWithoutMovie_genresInput
  update: GenresUpdateWithoutMovie_genresInput
  upsert: GenresUpsertWithoutMovie_genresInput
}

input GenresUpdateWithoutMovie_genresInput {
  genre: StringFieldUpdateOperationsInput
}

input GenresUpsertWithoutMovie_genresInput {
  create: GenresCreateWithoutMovie_genresInput!
  update: GenresUpdateWithoutMovie_genresInput!
}

input GenresWhereInput {
  AND: [GenresWhereInput!]
  NOT: [GenresWhereInput!]
  OR: [GenresWhereInput!]
  genre: StringFilter
  id: IntFilter
  movie_genres: Movie_genresListRelationFilter
}

input GenresWhereUniqueInput {
  id: Int
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input IntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

type Movie_genres {
  genre_id: Int!
  genres: Genres!
  movie_id: Int!
  movies: Movies!
}

type Movie_genresAvgAggregate {
  genre_id: Float
  movie_id: Float
}

input Movie_genresAvgOrderByAggregateInput {
  genre_id: SortOrder
  movie_id: SortOrder
}

type Movie_genresCountAggregate {
  _all: Int!
  genre_id: Int!
  movie_id: Int!
}

input Movie_genresCountOrderByAggregateInput {
  genre_id: SortOrder
  movie_id: SortOrder
}

input Movie_genresCreateInput {
  genres: GenresCreateNestedOneWithoutMovie_genresInput!
  movies: MoviesCreateNestedOneWithoutMovie_genresInput!
}

input Movie_genresCreateManyGenresInput {
  movie_id: Int!
}

input Movie_genresCreateManyGenresInputEnvelope {
  data: [Movie_genresCreateManyGenresInput!]!
  skipDuplicates: Boolean
}

input Movie_genresCreateManyInput {
  genre_id: Int!
  movie_id: Int!
}

input Movie_genresCreateManyMoviesInput {
  genre_id: Int!
}

input Movie_genresCreateManyMoviesInputEnvelope {
  data: [Movie_genresCreateManyMoviesInput!]!
  skipDuplicates: Boolean
}

input Movie_genresCreateNestedManyWithoutGenresInput {
  connect: [Movie_genresWhereUniqueInput!]
  connectOrCreate: [Movie_genresCreateOrConnectWithoutGenresInput!]
  create: [Movie_genresCreateWithoutGenresInput!]
  createMany: Movie_genresCreateManyGenresInputEnvelope
}

input Movie_genresCreateNestedManyWithoutMoviesInput {
  connect: [Movie_genresWhereUniqueInput!]
  connectOrCreate: [Movie_genresCreateOrConnectWithoutMoviesInput!]
  create: [Movie_genresCreateWithoutMoviesInput!]
  createMany: Movie_genresCreateManyMoviesInputEnvelope
}

input Movie_genresCreateOrConnectWithoutGenresInput {
  create: Movie_genresCreateWithoutGenresInput!
  where: Movie_genresWhereUniqueInput!
}

input Movie_genresCreateOrConnectWithoutMoviesInput {
  create: Movie_genresCreateWithoutMoviesInput!
  where: Movie_genresWhereUniqueInput!
}

input Movie_genresCreateWithoutGenresInput {
  movies: MoviesCreateNestedOneWithoutMovie_genresInput!
}

input Movie_genresCreateWithoutMoviesInput {
  genres: GenresCreateNestedOneWithoutMovie_genresInput!
}

type Movie_genresGroupBy {
  _avg: Movie_genresAvgAggregate
  _count: Movie_genresCountAggregate
  _max: Movie_genresMaxAggregate
  _min: Movie_genresMinAggregate
  _sum: Movie_genresSumAggregate
  genre_id: Int!
  movie_id: Int!
}

input Movie_genresListRelationFilter {
  every: Movie_genresWhereInput
  none: Movie_genresWhereInput
  some: Movie_genresWhereInput
}

type Movie_genresMaxAggregate {
  genre_id: Int
  movie_id: Int
}

input Movie_genresMaxOrderByAggregateInput {
  genre_id: SortOrder
  movie_id: SortOrder
}

type Movie_genresMinAggregate {
  genre_id: Int
  movie_id: Int
}

input Movie_genresMinOrderByAggregateInput {
  genre_id: SortOrder
  movie_id: SortOrder
}

input Movie_genresOrderByRelationAggregateInput {
  _count: SortOrder
}

input Movie_genresOrderByWithAggregationInput {
  _avg: Movie_genresAvgOrderByAggregateInput
  _count: Movie_genresCountOrderByAggregateInput
  _max: Movie_genresMaxOrderByAggregateInput
  _min: Movie_genresMinOrderByAggregateInput
  _sum: Movie_genresSumOrderByAggregateInput
  genre_id: SortOrder
  movie_id: SortOrder
}

input Movie_genresOrderByWithRelationInput {
  genre_id: SortOrder
  genres: GenresOrderByWithRelationInput
  movie_id: SortOrder
  movies: MoviesOrderByWithRelationInput
}

enum Movie_genresScalarFieldEnum {
  genre_id
  movie_id
}

input Movie_genresScalarWhereInput {
  AND: [Movie_genresScalarWhereInput!]
  NOT: [Movie_genresScalarWhereInput!]
  OR: [Movie_genresScalarWhereInput!]
  genre_id: IntFilter
  movie_id: IntFilter
}

input Movie_genresScalarWhereWithAggregatesInput {
  AND: [Movie_genresScalarWhereWithAggregatesInput!]
  NOT: [Movie_genresScalarWhereWithAggregatesInput!]
  OR: [Movie_genresScalarWhereWithAggregatesInput!]
  genre_id: IntWithAggregatesFilter
  movie_id: IntWithAggregatesFilter
}

type Movie_genresSumAggregate {
  genre_id: Int
  movie_id: Int
}

input Movie_genresSumOrderByAggregateInput {
  genre_id: SortOrder
  movie_id: SortOrder
}

input Movie_genresUpdateInput {
  genres: GenresUpdateOneRequiredWithoutMovie_genresNestedInput
  movies: MoviesUpdateOneRequiredWithoutMovie_genresNestedInput
}

input Movie_genresUpdateManyWithWhereWithoutGenresInput {
  where: Movie_genresScalarWhereInput!
}

input Movie_genresUpdateManyWithWhereWithoutMoviesInput {
  where: Movie_genresScalarWhereInput!
}

input Movie_genresUpdateManyWithoutGenresNestedInput {
  connect: [Movie_genresWhereUniqueInput!]
  connectOrCreate: [Movie_genresCreateOrConnectWithoutGenresInput!]
  create: [Movie_genresCreateWithoutGenresInput!]
  createMany: Movie_genresCreateManyGenresInputEnvelope
  delete: [Movie_genresWhereUniqueInput!]
  deleteMany: [Movie_genresScalarWhereInput!]
  disconnect: [Movie_genresWhereUniqueInput!]
  set: [Movie_genresWhereUniqueInput!]
  update: [Movie_genresUpdateWithWhereUniqueWithoutGenresInput!]
  updateMany: [Movie_genresUpdateManyWithWhereWithoutGenresInput!]
  upsert: [Movie_genresUpsertWithWhereUniqueWithoutGenresInput!]
}

input Movie_genresUpdateManyWithoutMoviesNestedInput {
  connect: [Movie_genresWhereUniqueInput!]
  connectOrCreate: [Movie_genresCreateOrConnectWithoutMoviesInput!]
  create: [Movie_genresCreateWithoutMoviesInput!]
  createMany: Movie_genresCreateManyMoviesInputEnvelope
  delete: [Movie_genresWhereUniqueInput!]
  deleteMany: [Movie_genresScalarWhereInput!]
  disconnect: [Movie_genresWhereUniqueInput!]
  set: [Movie_genresWhereUniqueInput!]
  update: [Movie_genresUpdateWithWhereUniqueWithoutMoviesInput!]
  updateMany: [Movie_genresUpdateManyWithWhereWithoutMoviesInput!]
  upsert: [Movie_genresUpsertWithWhereUniqueWithoutMoviesInput!]
}

input Movie_genresUpdateWithWhereUniqueWithoutGenresInput {
  data: Movie_genresUpdateWithoutGenresInput!
  where: Movie_genresWhereUniqueInput!
}

input Movie_genresUpdateWithWhereUniqueWithoutMoviesInput {
  data: Movie_genresUpdateWithoutMoviesInput!
  where: Movie_genresWhereUniqueInput!
}

input Movie_genresUpdateWithoutGenresInput {
  movies: MoviesUpdateOneRequiredWithoutMovie_genresNestedInput
}

input Movie_genresUpdateWithoutMoviesInput {
  genres: GenresUpdateOneRequiredWithoutMovie_genresNestedInput
}

input Movie_genresUpsertWithWhereUniqueWithoutGenresInput {
  create: Movie_genresCreateWithoutGenresInput!
  update: Movie_genresUpdateWithoutGenresInput!
  where: Movie_genresWhereUniqueInput!
}

input Movie_genresUpsertWithWhereUniqueWithoutMoviesInput {
  create: Movie_genresCreateWithoutMoviesInput!
  update: Movie_genresUpdateWithoutMoviesInput!
  where: Movie_genresWhereUniqueInput!
}

input Movie_genresWhereInput {
  AND: [Movie_genresWhereInput!]
  NOT: [Movie_genresWhereInput!]
  OR: [Movie_genresWhereInput!]
  genre_id: IntFilter
  genres: GenresRelationFilter
  movie_id: IntFilter
  movies: MoviesRelationFilter
}

input Movie_genresWhereUniqueInput {
  movie_id_genre_id: movie_genresMovie_idGenre_idCompoundUniqueInput
}

type Movies {
  _count: MoviesCount
  backdrop_path: String
  id: Int!
  movie_genres(cursor: Movie_genresWhereUniqueInput, distinct: [Movie_genresScalarFieldEnum!], orderBy: [Movie_genresOrderByWithRelationInput!], skip: Int, take: Int, where: Movie_genresWhereInput): [Movie_genres!]!
  overview: String
  popularity: Decimal
  poster_path: String
  ratings(cursor: RatingsWhereUniqueInput, distinct: [RatingsScalarFieldEnum!], orderBy: [RatingsOrderByWithRelationInput!], skip: Int, take: Int, where: RatingsWhereInput): [Ratings!]!
  release_date: DateTime
  runtime: Int
  title: String
  vote_average: Decimal
  vote_count: Int
}

type MoviesAvgAggregate {
  id: Float
  popularity: Decimal
  runtime: Float
  vote_average: Decimal
  vote_count: Float
}

input MoviesAvgOrderByAggregateInput {
  id: SortOrder
  popularity: SortOrder
  runtime: SortOrder
  vote_average: SortOrder
  vote_count: SortOrder
}

type MoviesCount {
  movie_genres(where: Movie_genresWhereInput): Int!
  ratings(where: RatingsWhereInput): Int!
}

type MoviesCountAggregate {
  _all: Int!
  backdrop_path: Int!
  id: Int!
  overview: Int!
  popularity: Int!
  poster_path: Int!
  release_date: Int!
  runtime: Int!
  title: Int!
  vote_average: Int!
  vote_count: Int!
}

input MoviesCountOrderByAggregateInput {
  backdrop_path: SortOrder
  id: SortOrder
  overview: SortOrder
  popularity: SortOrder
  poster_path: SortOrder
  release_date: SortOrder
  runtime: SortOrder
  title: SortOrder
  vote_average: SortOrder
  vote_count: SortOrder
}

input MoviesCreateInput {
  backdrop_path: String
  id: Int!
  movie_genres: Movie_genresCreateNestedManyWithoutMoviesInput
  overview: String
  popularity: Decimal
  poster_path: String
  ratings: RatingsCreateNestedManyWithoutMoviesInput
  release_date: DateTime
  runtime: Int
  title: String
  vote_average: Decimal
  vote_count: Int
}

input MoviesCreateManyInput {
  backdrop_path: String
  id: Int!
  overview: String
  popularity: Decimal
  poster_path: String
  release_date: DateTime
  runtime: Int
  title: String
  vote_average: Decimal
  vote_count: Int
}

input MoviesCreateNestedOneWithoutMovie_genresInput {
  connect: MoviesWhereUniqueInput
  connectOrCreate: MoviesCreateOrConnectWithoutMovie_genresInput
  create: MoviesCreateWithoutMovie_genresInput
}

input MoviesCreateNestedOneWithoutRatingsInput {
  connect: MoviesWhereUniqueInput
  connectOrCreate: MoviesCreateOrConnectWithoutRatingsInput
  create: MoviesCreateWithoutRatingsInput
}

input MoviesCreateOrConnectWithoutMovie_genresInput {
  create: MoviesCreateWithoutMovie_genresInput!
  where: MoviesWhereUniqueInput!
}

input MoviesCreateOrConnectWithoutRatingsInput {
  create: MoviesCreateWithoutRatingsInput!
  where: MoviesWhereUniqueInput!
}

input MoviesCreateWithoutMovie_genresInput {
  backdrop_path: String
  id: Int!
  overview: String
  popularity: Decimal
  poster_path: String
  ratings: RatingsCreateNestedManyWithoutMoviesInput
  release_date: DateTime
  runtime: Int
  title: String
  vote_average: Decimal
  vote_count: Int
}

input MoviesCreateWithoutRatingsInput {
  backdrop_path: String
  id: Int!
  movie_genres: Movie_genresCreateNestedManyWithoutMoviesInput
  overview: String
  popularity: Decimal
  poster_path: String
  release_date: DateTime
  runtime: Int
  title: String
  vote_average: Decimal
  vote_count: Int
}

type MoviesGroupBy {
  _avg: MoviesAvgAggregate
  _count: MoviesCountAggregate
  _max: MoviesMaxAggregate
  _min: MoviesMinAggregate
  _sum: MoviesSumAggregate
  backdrop_path: String
  id: Int!
  overview: String
  popularity: Decimal
  poster_path: String
  release_date: DateTime
  runtime: Int
  title: String
  vote_average: Decimal
  vote_count: Int
}

type MoviesMaxAggregate {
  backdrop_path: String
  id: Int
  overview: String
  popularity: Decimal
  poster_path: String
  release_date: DateTime
  runtime: Int
  title: String
  vote_average: Decimal
  vote_count: Int
}

input MoviesMaxOrderByAggregateInput {
  backdrop_path: SortOrder
  id: SortOrder
  overview: SortOrder
  popularity: SortOrder
  poster_path: SortOrder
  release_date: SortOrder
  runtime: SortOrder
  title: SortOrder
  vote_average: SortOrder
  vote_count: SortOrder
}

type MoviesMinAggregate {
  backdrop_path: String
  id: Int
  overview: String
  popularity: Decimal
  poster_path: String
  release_date: DateTime
  runtime: Int
  title: String
  vote_average: Decimal
  vote_count: Int
}

input MoviesMinOrderByAggregateInput {
  backdrop_path: SortOrder
  id: SortOrder
  overview: SortOrder
  popularity: SortOrder
  poster_path: SortOrder
  release_date: SortOrder
  runtime: SortOrder
  title: SortOrder
  vote_average: SortOrder
  vote_count: SortOrder
}

input MoviesOrderByWithAggregationInput {
  _avg: MoviesAvgOrderByAggregateInput
  _count: MoviesCountOrderByAggregateInput
  _max: MoviesMaxOrderByAggregateInput
  _min: MoviesMinOrderByAggregateInput
  _sum: MoviesSumOrderByAggregateInput
  backdrop_path: SortOrderInput
  id: SortOrder
  overview: SortOrderInput
  popularity: SortOrderInput
  poster_path: SortOrderInput
  release_date: SortOrderInput
  runtime: SortOrderInput
  title: SortOrderInput
  vote_average: SortOrderInput
  vote_count: SortOrderInput
}

input MoviesOrderByWithRelationInput {
  backdrop_path: SortOrderInput
  id: SortOrder
  movie_genres: Movie_genresOrderByRelationAggregateInput
  overview: SortOrderInput
  popularity: SortOrderInput
  poster_path: SortOrderInput
  ratings: RatingsOrderByRelationAggregateInput
  release_date: SortOrderInput
  runtime: SortOrderInput
  title: SortOrderInput
  vote_average: SortOrderInput
  vote_count: SortOrderInput
}

input MoviesRelationFilter {
  is: MoviesWhereInput
  isNot: MoviesWhereInput
}

enum MoviesScalarFieldEnum {
  backdrop_path
  id
  overview
  popularity
  poster_path
  release_date
  runtime
  title
  vote_average
  vote_count
}

input MoviesScalarWhereWithAggregatesInput {
  AND: [MoviesScalarWhereWithAggregatesInput!]
  NOT: [MoviesScalarWhereWithAggregatesInput!]
  OR: [MoviesScalarWhereWithAggregatesInput!]
  backdrop_path: StringNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  overview: StringNullableWithAggregatesFilter
  popularity: DecimalNullableWithAggregatesFilter
  poster_path: StringNullableWithAggregatesFilter
  release_date: DateTimeNullableWithAggregatesFilter
  runtime: IntNullableWithAggregatesFilter
  title: StringNullableWithAggregatesFilter
  vote_average: DecimalNullableWithAggregatesFilter
  vote_count: IntNullableWithAggregatesFilter
}

type MoviesSumAggregate {
  id: Int
  popularity: Decimal
  runtime: Int
  vote_average: Decimal
  vote_count: Int
}

input MoviesSumOrderByAggregateInput {
  id: SortOrder
  popularity: SortOrder
  runtime: SortOrder
  vote_average: SortOrder
  vote_count: SortOrder
}

input MoviesUpdateInput {
  backdrop_path: NullableStringFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  movie_genres: Movie_genresUpdateManyWithoutMoviesNestedInput
  overview: NullableStringFieldUpdateOperationsInput
  popularity: NullableDecimalFieldUpdateOperationsInput
  poster_path: NullableStringFieldUpdateOperationsInput
  ratings: RatingsUpdateManyWithoutMoviesNestedInput
  release_date: NullableDateTimeFieldUpdateOperationsInput
  runtime: NullableIntFieldUpdateOperationsInput
  title: NullableStringFieldUpdateOperationsInput
  vote_average: NullableDecimalFieldUpdateOperationsInput
  vote_count: NullableIntFieldUpdateOperationsInput
}

input MoviesUpdateManyMutationInput {
  backdrop_path: NullableStringFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  overview: NullableStringFieldUpdateOperationsInput
  popularity: NullableDecimalFieldUpdateOperationsInput
  poster_path: NullableStringFieldUpdateOperationsInput
  release_date: NullableDateTimeFieldUpdateOperationsInput
  runtime: NullableIntFieldUpdateOperationsInput
  title: NullableStringFieldUpdateOperationsInput
  vote_average: NullableDecimalFieldUpdateOperationsInput
  vote_count: NullableIntFieldUpdateOperationsInput
}

input MoviesUpdateOneRequiredWithoutMovie_genresNestedInput {
  connect: MoviesWhereUniqueInput
  connectOrCreate: MoviesCreateOrConnectWithoutMovie_genresInput
  create: MoviesCreateWithoutMovie_genresInput
  update: MoviesUpdateWithoutMovie_genresInput
  upsert: MoviesUpsertWithoutMovie_genresInput
}

input MoviesUpdateOneRequiredWithoutRatingsNestedInput {
  connect: MoviesWhereUniqueInput
  connectOrCreate: MoviesCreateOrConnectWithoutRatingsInput
  create: MoviesCreateWithoutRatingsInput
  update: MoviesUpdateWithoutRatingsInput
  upsert: MoviesUpsertWithoutRatingsInput
}

input MoviesUpdateWithoutMovie_genresInput {
  backdrop_path: NullableStringFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  overview: NullableStringFieldUpdateOperationsInput
  popularity: NullableDecimalFieldUpdateOperationsInput
  poster_path: NullableStringFieldUpdateOperationsInput
  ratings: RatingsUpdateManyWithoutMoviesNestedInput
  release_date: NullableDateTimeFieldUpdateOperationsInput
  runtime: NullableIntFieldUpdateOperationsInput
  title: NullableStringFieldUpdateOperationsInput
  vote_average: NullableDecimalFieldUpdateOperationsInput
  vote_count: NullableIntFieldUpdateOperationsInput
}

input MoviesUpdateWithoutRatingsInput {
  backdrop_path: NullableStringFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  movie_genres: Movie_genresUpdateManyWithoutMoviesNestedInput
  overview: NullableStringFieldUpdateOperationsInput
  popularity: NullableDecimalFieldUpdateOperationsInput
  poster_path: NullableStringFieldUpdateOperationsInput
  release_date: NullableDateTimeFieldUpdateOperationsInput
  runtime: NullableIntFieldUpdateOperationsInput
  title: NullableStringFieldUpdateOperationsInput
  vote_average: NullableDecimalFieldUpdateOperationsInput
  vote_count: NullableIntFieldUpdateOperationsInput
}

input MoviesUpsertWithoutMovie_genresInput {
  create: MoviesCreateWithoutMovie_genresInput!
  update: MoviesUpdateWithoutMovie_genresInput!
}

input MoviesUpsertWithoutRatingsInput {
  create: MoviesCreateWithoutRatingsInput!
  update: MoviesUpdateWithoutRatingsInput!
}

input MoviesWhereInput {
  AND: [MoviesWhereInput!]
  NOT: [MoviesWhereInput!]
  OR: [MoviesWhereInput!]
  backdrop_path: StringNullableFilter
  id: IntFilter
  movie_genres: Movie_genresListRelationFilter
  overview: StringNullableFilter
  popularity: DecimalNullableFilter
  poster_path: StringNullableFilter
  ratings: RatingsListRelationFilter
  release_date: DateTimeNullableFilter
  runtime: IntNullableFilter
  title: StringNullableFilter
  vote_average: DecimalNullableFilter
  vote_count: IntNullableFilter
}

input MoviesWhereUniqueInput {
  id: Int
}

type Mutation {
  createManyGenres(data: [GenresCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyMovie_genres(data: [Movie_genresCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyMovies(data: [MoviesCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyRatings(data: [RatingsCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyUsers(data: [UsersCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOneGenres(data: GenresCreateInput!): Genres!
  createOneMovie_genres(data: Movie_genresCreateInput!): Movie_genres!
  createOneMovies(data: MoviesCreateInput!): Movies!
  createOneRatings(data: RatingsCreateInput!): Ratings!
  createOneUsers(data: UsersCreateInput!): Users!
  deleteManyGenres(where: GenresWhereInput): AffectedRowsOutput!
  deleteManyMovie_genres(where: Movie_genresWhereInput): AffectedRowsOutput!
  deleteManyMovies(where: MoviesWhereInput): AffectedRowsOutput!
  deleteManyRatings(where: RatingsWhereInput): AffectedRowsOutput!
  deleteManyUsers(where: UsersWhereInput): AffectedRowsOutput!
  deleteOneGenres(where: GenresWhereUniqueInput!): Genres
  deleteOneMovie_genres(where: Movie_genresWhereUniqueInput!): Movie_genres
  deleteOneMovies(where: MoviesWhereUniqueInput!): Movies
  deleteOneRatings(where: RatingsWhereUniqueInput!): Ratings
  deleteOneUsers(where: UsersWhereUniqueInput!): Users
  updateManyGenres(data: GenresUpdateManyMutationInput!, where: GenresWhereInput): AffectedRowsOutput!
  updateManyMovie_genres(where: Movie_genresWhereInput): AffectedRowsOutput!
  updateManyMovies(data: MoviesUpdateManyMutationInput!, where: MoviesWhereInput): AffectedRowsOutput!
  updateManyRatings(data: RatingsUpdateManyMutationInput!, where: RatingsWhereInput): AffectedRowsOutput!
  updateManyUsers(data: UsersUpdateManyMutationInput!, where: UsersWhereInput): AffectedRowsOutput!
  updateOneGenres(data: GenresUpdateInput!, where: GenresWhereUniqueInput!): Genres
  updateOneMovie_genres(data: Movie_genresUpdateInput!, where: Movie_genresWhereUniqueInput!): Movie_genres
  updateOneMovies(data: MoviesUpdateInput!, where: MoviesWhereUniqueInput!): Movies
  updateOneRatings(data: RatingsUpdateInput!, where: RatingsWhereUniqueInput!): Ratings
  updateOneUsers(data: UsersUpdateInput!, where: UsersWhereUniqueInput!): Users
  upsertOneGenres(create: GenresCreateInput!, update: GenresUpdateInput!, where: GenresWhereUniqueInput!): Genres!
  upsertOneMovie_genres(create: Movie_genresCreateInput!, update: Movie_genresUpdateInput!, where: Movie_genresWhereUniqueInput!): Movie_genres!
  upsertOneMovies(create: MoviesCreateInput!, update: MoviesUpdateInput!, where: MoviesWhereUniqueInput!): Movies!
  upsertOneRatings(create: RatingsCreateInput!, update: RatingsUpdateInput!, where: RatingsWhereUniqueInput!): Ratings!
  upsertOneUsers(create: UsersCreateInput!, update: UsersUpdateInput!, where: UsersWhereUniqueInput!): Users!
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedDecimalNullableFilter {
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalNullableFilter
  notIn: [Decimal!]
}

input NestedDecimalNullableWithAggregatesFilter {
  _avg: NestedDecimalNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedDecimalNullableFilter
  _min: NestedDecimalNullableFilter
  _sum: NestedDecimalNullableFilter
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalNullableWithAggregatesFilter
  notIn: [Decimal!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input NestedFloatWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedFloatFilter
  _min: NestedFloatFilter
  _sum: NestedFloatFilter
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatWithAggregatesFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NullableDateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input NullableDecimalFieldUpdateOperationsInput {
  decrement: Decimal
  divide: Decimal
  increment: Decimal
  multiply: Decimal
  set: Decimal
}

input NullableIntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

enum NullsOrder {
  first
  last
}

type Query {
  aggregateGenres(cursor: GenresWhereUniqueInput, orderBy: [GenresOrderByWithRelationInput!], skip: Int, take: Int, where: GenresWhereInput): AggregateGenres!
  aggregateMovie_genres(cursor: Movie_genresWhereUniqueInput, orderBy: [Movie_genresOrderByWithRelationInput!], skip: Int, take: Int, where: Movie_genresWhereInput): AggregateMovie_genres!
  aggregateMovies(cursor: MoviesWhereUniqueInput, orderBy: [MoviesOrderByWithRelationInput!], skip: Int, take: Int, where: MoviesWhereInput): AggregateMovies!
  aggregateRatings(cursor: RatingsWhereUniqueInput, orderBy: [RatingsOrderByWithRelationInput!], skip: Int, take: Int, where: RatingsWhereInput): AggregateRatings!
  aggregateUsers(cursor: UsersWhereUniqueInput, orderBy: [UsersOrderByWithRelationInput!], skip: Int, take: Int, where: UsersWhereInput): AggregateUsers!
  findFirstGenres(cursor: GenresWhereUniqueInput, distinct: [GenresScalarFieldEnum!], orderBy: [GenresOrderByWithRelationInput!], skip: Int, take: Int, where: GenresWhereInput): Genres
  findFirstGenresOrThrow(cursor: GenresWhereUniqueInput, distinct: [GenresScalarFieldEnum!], orderBy: [GenresOrderByWithRelationInput!], skip: Int, take: Int, where: GenresWhereInput): Genres
  findFirstMovie_genres(cursor: Movie_genresWhereUniqueInput, distinct: [Movie_genresScalarFieldEnum!], orderBy: [Movie_genresOrderByWithRelationInput!], skip: Int, take: Int, where: Movie_genresWhereInput): Movie_genres
  findFirstMovie_genresOrThrow(cursor: Movie_genresWhereUniqueInput, distinct: [Movie_genresScalarFieldEnum!], orderBy: [Movie_genresOrderByWithRelationInput!], skip: Int, take: Int, where: Movie_genresWhereInput): Movie_genres
  findFirstMovies(cursor: MoviesWhereUniqueInput, distinct: [MoviesScalarFieldEnum!], orderBy: [MoviesOrderByWithRelationInput!], skip: Int, take: Int, where: MoviesWhereInput): Movies
  findFirstMoviesOrThrow(cursor: MoviesWhereUniqueInput, distinct: [MoviesScalarFieldEnum!], orderBy: [MoviesOrderByWithRelationInput!], skip: Int, take: Int, where: MoviesWhereInput): Movies
  findFirstRatings(cursor: RatingsWhereUniqueInput, distinct: [RatingsScalarFieldEnum!], orderBy: [RatingsOrderByWithRelationInput!], skip: Int, take: Int, where: RatingsWhereInput): Ratings
  findFirstRatingsOrThrow(cursor: RatingsWhereUniqueInput, distinct: [RatingsScalarFieldEnum!], orderBy: [RatingsOrderByWithRelationInput!], skip: Int, take: Int, where: RatingsWhereInput): Ratings
  findFirstUsers(cursor: UsersWhereUniqueInput, distinct: [UsersScalarFieldEnum!], orderBy: [UsersOrderByWithRelationInput!], skip: Int, take: Int, where: UsersWhereInput): Users
  findFirstUsersOrThrow(cursor: UsersWhereUniqueInput, distinct: [UsersScalarFieldEnum!], orderBy: [UsersOrderByWithRelationInput!], skip: Int, take: Int, where: UsersWhereInput): Users
  findManyGenres(cursor: GenresWhereUniqueInput, distinct: [GenresScalarFieldEnum!], orderBy: [GenresOrderByWithRelationInput!], skip: Int, take: Int, where: GenresWhereInput): [Genres!]!
  findManyMovie_genres(cursor: Movie_genresWhereUniqueInput, distinct: [Movie_genresScalarFieldEnum!], orderBy: [Movie_genresOrderByWithRelationInput!], skip: Int, take: Int, where: Movie_genresWhereInput): [Movie_genres!]!
  findManyMovies(cursor: MoviesWhereUniqueInput, distinct: [MoviesScalarFieldEnum!], orderBy: [MoviesOrderByWithRelationInput!], skip: Int, take: Int, where: MoviesWhereInput): [Movies!]!
  findManyRatings(cursor: RatingsWhereUniqueInput, distinct: [RatingsScalarFieldEnum!], orderBy: [RatingsOrderByWithRelationInput!], skip: Int, take: Int, where: RatingsWhereInput): [Ratings!]!
  findManyUsers(cursor: UsersWhereUniqueInput, distinct: [UsersScalarFieldEnum!], orderBy: [UsersOrderByWithRelationInput!], skip: Int, take: Int, where: UsersWhereInput): [Users!]!
  findUniqueGenres(where: GenresWhereUniqueInput!): Genres
  findUniqueGenresOrThrow(where: GenresWhereUniqueInput!): Genres
  findUniqueMovie_genres(where: Movie_genresWhereUniqueInput!): Movie_genres
  findUniqueMovie_genresOrThrow(where: Movie_genresWhereUniqueInput!): Movie_genres
  findUniqueMovies(where: MoviesWhereUniqueInput!): Movies
  findUniqueMoviesOrThrow(where: MoviesWhereUniqueInput!): Movies
  findUniqueRatings(where: RatingsWhereUniqueInput!): Ratings
  findUniqueRatingsOrThrow(where: RatingsWhereUniqueInput!): Ratings
  findUniqueUsers(where: UsersWhereUniqueInput!): Users
  findUniqueUsersOrThrow(where: UsersWhereUniqueInput!): Users
  groupByGenres(by: [GenresScalarFieldEnum!]!, having: GenresScalarWhereWithAggregatesInput, orderBy: [GenresOrderByWithAggregationInput!], skip: Int, take: Int, where: GenresWhereInput): [GenresGroupBy!]!
  groupByMovie_genres(by: [Movie_genresScalarFieldEnum!]!, having: Movie_genresScalarWhereWithAggregatesInput, orderBy: [Movie_genresOrderByWithAggregationInput!], skip: Int, take: Int, where: Movie_genresWhereInput): [Movie_genresGroupBy!]!
  groupByMovies(by: [MoviesScalarFieldEnum!]!, having: MoviesScalarWhereWithAggregatesInput, orderBy: [MoviesOrderByWithAggregationInput!], skip: Int, take: Int, where: MoviesWhereInput): [MoviesGroupBy!]!
  groupByRatings(by: [RatingsScalarFieldEnum!]!, having: RatingsScalarWhereWithAggregatesInput, orderBy: [RatingsOrderByWithAggregationInput!], skip: Int, take: Int, where: RatingsWhereInput): [RatingsGroupBy!]!
  groupByUsers(by: [UsersScalarFieldEnum!]!, having: UsersScalarWhereWithAggregatesInput, orderBy: [UsersOrderByWithAggregationInput!], skip: Int, take: Int, where: UsersWhereInput): [UsersGroupBy!]!
}

enum QueryMode {
  default
  insensitive
}

type Ratings {
  movie_id: Int!
  movies: Movies!
  rating: Float!
  user_id: Int!
  users: Users!
}

type RatingsAvgAggregate {
  movie_id: Float
  rating: Float
  user_id: Float
}

input RatingsAvgOrderByAggregateInput {
  movie_id: SortOrder
  rating: SortOrder
  user_id: SortOrder
}

type RatingsCountAggregate {
  _all: Int!
  movie_id: Int!
  rating: Int!
  user_id: Int!
}

input RatingsCountOrderByAggregateInput {
  movie_id: SortOrder
  rating: SortOrder
  user_id: SortOrder
}

input RatingsCreateInput {
  movies: MoviesCreateNestedOneWithoutRatingsInput!
  rating: Float!
  users: UsersCreateNestedOneWithoutRatingsInput!
}

input RatingsCreateManyInput {
  movie_id: Int!
  rating: Float!
  user_id: Int!
}

input RatingsCreateManyMoviesInput {
  rating: Float!
  user_id: Int!
}

input RatingsCreateManyMoviesInputEnvelope {
  data: [RatingsCreateManyMoviesInput!]!
  skipDuplicates: Boolean
}

input RatingsCreateManyUsersInput {
  movie_id: Int!
  rating: Float!
}

input RatingsCreateManyUsersInputEnvelope {
  data: [RatingsCreateManyUsersInput!]!
  skipDuplicates: Boolean
}

input RatingsCreateNestedManyWithoutMoviesInput {
  connect: [RatingsWhereUniqueInput!]
  connectOrCreate: [RatingsCreateOrConnectWithoutMoviesInput!]
  create: [RatingsCreateWithoutMoviesInput!]
  createMany: RatingsCreateManyMoviesInputEnvelope
}

input RatingsCreateNestedManyWithoutUsersInput {
  connect: [RatingsWhereUniqueInput!]
  connectOrCreate: [RatingsCreateOrConnectWithoutUsersInput!]
  create: [RatingsCreateWithoutUsersInput!]
  createMany: RatingsCreateManyUsersInputEnvelope
}

input RatingsCreateOrConnectWithoutMoviesInput {
  create: RatingsCreateWithoutMoviesInput!
  where: RatingsWhereUniqueInput!
}

input RatingsCreateOrConnectWithoutUsersInput {
  create: RatingsCreateWithoutUsersInput!
  where: RatingsWhereUniqueInput!
}

input RatingsCreateWithoutMoviesInput {
  rating: Float!
  users: UsersCreateNestedOneWithoutRatingsInput!
}

input RatingsCreateWithoutUsersInput {
  movies: MoviesCreateNestedOneWithoutRatingsInput!
  rating: Float!
}

type RatingsGroupBy {
  _avg: RatingsAvgAggregate
  _count: RatingsCountAggregate
  _max: RatingsMaxAggregate
  _min: RatingsMinAggregate
  _sum: RatingsSumAggregate
  movie_id: Int!
  rating: Float!
  user_id: Int!
}

input RatingsListRelationFilter {
  every: RatingsWhereInput
  none: RatingsWhereInput
  some: RatingsWhereInput
}

type RatingsMaxAggregate {
  movie_id: Int
  rating: Float
  user_id: Int
}

input RatingsMaxOrderByAggregateInput {
  movie_id: SortOrder
  rating: SortOrder
  user_id: SortOrder
}

type RatingsMinAggregate {
  movie_id: Int
  rating: Float
  user_id: Int
}

input RatingsMinOrderByAggregateInput {
  movie_id: SortOrder
  rating: SortOrder
  user_id: SortOrder
}

input RatingsOrderByRelationAggregateInput {
  _count: SortOrder
}

input RatingsOrderByWithAggregationInput {
  _avg: RatingsAvgOrderByAggregateInput
  _count: RatingsCountOrderByAggregateInput
  _max: RatingsMaxOrderByAggregateInput
  _min: RatingsMinOrderByAggregateInput
  _sum: RatingsSumOrderByAggregateInput
  movie_id: SortOrder
  rating: SortOrder
  user_id: SortOrder
}

input RatingsOrderByWithRelationInput {
  movie_id: SortOrder
  movies: MoviesOrderByWithRelationInput
  rating: SortOrder
  user_id: SortOrder
  users: UsersOrderByWithRelationInput
}

enum RatingsScalarFieldEnum {
  movie_id
  rating
  user_id
}

input RatingsScalarWhereInput {
  AND: [RatingsScalarWhereInput!]
  NOT: [RatingsScalarWhereInput!]
  OR: [RatingsScalarWhereInput!]
  movie_id: IntFilter
  rating: FloatFilter
  user_id: IntFilter
}

input RatingsScalarWhereWithAggregatesInput {
  AND: [RatingsScalarWhereWithAggregatesInput!]
  NOT: [RatingsScalarWhereWithAggregatesInput!]
  OR: [RatingsScalarWhereWithAggregatesInput!]
  movie_id: IntWithAggregatesFilter
  rating: FloatWithAggregatesFilter
  user_id: IntWithAggregatesFilter
}

type RatingsSumAggregate {
  movie_id: Int
  rating: Float
  user_id: Int
}

input RatingsSumOrderByAggregateInput {
  movie_id: SortOrder
  rating: SortOrder
  user_id: SortOrder
}

input RatingsUpdateInput {
  movies: MoviesUpdateOneRequiredWithoutRatingsNestedInput
  rating: FloatFieldUpdateOperationsInput
  users: UsersUpdateOneRequiredWithoutRatingsNestedInput
}

input RatingsUpdateManyMutationInput {
  rating: FloatFieldUpdateOperationsInput
}

input RatingsUpdateManyWithWhereWithoutMoviesInput {
  data: RatingsUpdateManyMutationInput!
  where: RatingsScalarWhereInput!
}

input RatingsUpdateManyWithWhereWithoutUsersInput {
  data: RatingsUpdateManyMutationInput!
  where: RatingsScalarWhereInput!
}

input RatingsUpdateManyWithoutMoviesNestedInput {
  connect: [RatingsWhereUniqueInput!]
  connectOrCreate: [RatingsCreateOrConnectWithoutMoviesInput!]
  create: [RatingsCreateWithoutMoviesInput!]
  createMany: RatingsCreateManyMoviesInputEnvelope
  delete: [RatingsWhereUniqueInput!]
  deleteMany: [RatingsScalarWhereInput!]
  disconnect: [RatingsWhereUniqueInput!]
  set: [RatingsWhereUniqueInput!]
  update: [RatingsUpdateWithWhereUniqueWithoutMoviesInput!]
  updateMany: [RatingsUpdateManyWithWhereWithoutMoviesInput!]
  upsert: [RatingsUpsertWithWhereUniqueWithoutMoviesInput!]
}

input RatingsUpdateManyWithoutUsersNestedInput {
  connect: [RatingsWhereUniqueInput!]
  connectOrCreate: [RatingsCreateOrConnectWithoutUsersInput!]
  create: [RatingsCreateWithoutUsersInput!]
  createMany: RatingsCreateManyUsersInputEnvelope
  delete: [RatingsWhereUniqueInput!]
  deleteMany: [RatingsScalarWhereInput!]
  disconnect: [RatingsWhereUniqueInput!]
  set: [RatingsWhereUniqueInput!]
  update: [RatingsUpdateWithWhereUniqueWithoutUsersInput!]
  updateMany: [RatingsUpdateManyWithWhereWithoutUsersInput!]
  upsert: [RatingsUpsertWithWhereUniqueWithoutUsersInput!]
}

input RatingsUpdateWithWhereUniqueWithoutMoviesInput {
  data: RatingsUpdateWithoutMoviesInput!
  where: RatingsWhereUniqueInput!
}

input RatingsUpdateWithWhereUniqueWithoutUsersInput {
  data: RatingsUpdateWithoutUsersInput!
  where: RatingsWhereUniqueInput!
}

input RatingsUpdateWithoutMoviesInput {
  rating: FloatFieldUpdateOperationsInput
  users: UsersUpdateOneRequiredWithoutRatingsNestedInput
}

input RatingsUpdateWithoutUsersInput {
  movies: MoviesUpdateOneRequiredWithoutRatingsNestedInput
  rating: FloatFieldUpdateOperationsInput
}

input RatingsUpsertWithWhereUniqueWithoutMoviesInput {
  create: RatingsCreateWithoutMoviesInput!
  update: RatingsUpdateWithoutMoviesInput!
  where: RatingsWhereUniqueInput!
}

input RatingsUpsertWithWhereUniqueWithoutUsersInput {
  create: RatingsCreateWithoutUsersInput!
  update: RatingsUpdateWithoutUsersInput!
  where: RatingsWhereUniqueInput!
}

input RatingsWhereInput {
  AND: [RatingsWhereInput!]
  NOT: [RatingsWhereInput!]
  OR: [RatingsWhereInput!]
  movie_id: IntFilter
  movies: MoviesRelationFilter
  rating: FloatFilter
  user_id: IntFilter
  users: UsersRelationFilter
}

input RatingsWhereUniqueInput {
  user_id_movie_id: ratingsUser_idMovie_idCompoundUniqueInput
}

enum SortOrder {
  asc
  desc
}

input SortOrderInput {
  nulls: NullsOrder
  sort: SortOrder!
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Users {
  _count: UsersCount
  id: Int!
  password: String!
  ratings(cursor: RatingsWhereUniqueInput, distinct: [RatingsScalarFieldEnum!], orderBy: [RatingsOrderByWithRelationInput!], skip: Int, take: Int, where: RatingsWhereInput): [Ratings!]!
  username: String!
}

type UsersAvgAggregate {
  id: Float
}

input UsersAvgOrderByAggregateInput {
  id: SortOrder
}

type UsersCount {
  ratings(where: RatingsWhereInput): Int!
}

type UsersCountAggregate {
  _all: Int!
  id: Int!
  password: Int!
  username: Int!
}

input UsersCountOrderByAggregateInput {
  id: SortOrder
  password: SortOrder
  username: SortOrder
}

input UsersCreateInput {
  password: String!
  ratings: RatingsCreateNestedManyWithoutUsersInput
  username: String!
}

input UsersCreateManyInput {
  id: Int
  password: String!
  username: String!
}

input UsersCreateNestedOneWithoutRatingsInput {
  connect: UsersWhereUniqueInput
  connectOrCreate: UsersCreateOrConnectWithoutRatingsInput
  create: UsersCreateWithoutRatingsInput
}

input UsersCreateOrConnectWithoutRatingsInput {
  create: UsersCreateWithoutRatingsInput!
  where: UsersWhereUniqueInput!
}

input UsersCreateWithoutRatingsInput {
  password: String!
  username: String!
}

type UsersGroupBy {
  _avg: UsersAvgAggregate
  _count: UsersCountAggregate
  _max: UsersMaxAggregate
  _min: UsersMinAggregate
  _sum: UsersSumAggregate
  id: Int!
  password: String!
  username: String!
}

type UsersMaxAggregate {
  id: Int
  password: String
  username: String
}

input UsersMaxOrderByAggregateInput {
  id: SortOrder
  password: SortOrder
  username: SortOrder
}

type UsersMinAggregate {
  id: Int
  password: String
  username: String
}

input UsersMinOrderByAggregateInput {
  id: SortOrder
  password: SortOrder
  username: SortOrder
}

input UsersOrderByWithAggregationInput {
  _avg: UsersAvgOrderByAggregateInput
  _count: UsersCountOrderByAggregateInput
  _max: UsersMaxOrderByAggregateInput
  _min: UsersMinOrderByAggregateInput
  _sum: UsersSumOrderByAggregateInput
  id: SortOrder
  password: SortOrder
  username: SortOrder
}

input UsersOrderByWithRelationInput {
  id: SortOrder
  password: SortOrder
  ratings: RatingsOrderByRelationAggregateInput
  username: SortOrder
}

input UsersRelationFilter {
  is: UsersWhereInput
  isNot: UsersWhereInput
}

enum UsersScalarFieldEnum {
  id
  password
  username
}

input UsersScalarWhereWithAggregatesInput {
  AND: [UsersScalarWhereWithAggregatesInput!]
  NOT: [UsersScalarWhereWithAggregatesInput!]
  OR: [UsersScalarWhereWithAggregatesInput!]
  id: IntWithAggregatesFilter
  password: StringWithAggregatesFilter
  username: StringWithAggregatesFilter
}

type UsersSumAggregate {
  id: Int
}

input UsersSumOrderByAggregateInput {
  id: SortOrder
}

input UsersUpdateInput {
  password: StringFieldUpdateOperationsInput
  ratings: RatingsUpdateManyWithoutUsersNestedInput
  username: StringFieldUpdateOperationsInput
}

input UsersUpdateManyMutationInput {
  password: StringFieldUpdateOperationsInput
  username: StringFieldUpdateOperationsInput
}

input UsersUpdateOneRequiredWithoutRatingsNestedInput {
  connect: UsersWhereUniqueInput
  connectOrCreate: UsersCreateOrConnectWithoutRatingsInput
  create: UsersCreateWithoutRatingsInput
  update: UsersUpdateWithoutRatingsInput
  upsert: UsersUpsertWithoutRatingsInput
}

input UsersUpdateWithoutRatingsInput {
  password: StringFieldUpdateOperationsInput
  username: StringFieldUpdateOperationsInput
}

input UsersUpsertWithoutRatingsInput {
  create: UsersCreateWithoutRatingsInput!
  update: UsersUpdateWithoutRatingsInput!
}

input UsersWhereInput {
  AND: [UsersWhereInput!]
  NOT: [UsersWhereInput!]
  OR: [UsersWhereInput!]
  id: IntFilter
  password: StringFilter
  ratings: RatingsListRelationFilter
  username: StringFilter
}

input UsersWhereUniqueInput {
  id: Int
}

input movie_genresMovie_idGenre_idCompoundUniqueInput {
  genre_id: Int!
  movie_id: Int!
}

input ratingsUser_idMovie_idCompoundUniqueInput {
  movie_id: Int!
  user_id: Int!
}